// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/artifactregistry/Repository.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/tgc_next/services/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package artifactregistry

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"reflect"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/tgcresource"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/tpgresource"
	transport_tpg "github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/transport"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/verify"
)

func upstreamPoliciesDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	o, n := d.GetChange("virtual_repository_config.0.upstream_policies")
	oldPolicies, ok := o.([]any)
	if !ok {
		return false
	}
	newPolicies, ok := n.([]any)
	if !ok {
		return false
	}

	var oldHashes, newHashes []interface{}
	for _, policy := range oldPolicies {
		data, ok := policy.(map[string]any)
		if !ok {
			return false
		}
		hashStr := fmt.Sprintf("[id:%v priority:%v repository:%v]", data["id"], data["priority"], data["repository"])
		oldHashes = append(oldHashes, hashStr)
	}
	for _, policy := range newPolicies {
		data, ok := policy.(map[string]any)
		if !ok {
			return false
		}
		hashStr := fmt.Sprintf("[id:%v priority:%v repository:%v]", data["id"], data["priority"], data["repository"])
		newHashes = append(newHashes, hashStr)
	}

	oldSet := schema.NewSet(schema.HashString, oldHashes)
	newSet := schema.NewSet(schema.HashString, newHashes)
	return oldSet.Equal(newSet)
}

func parseDurationAsSeconds(v string) (int, bool) {
	if len(v) == 0 {
		return 0, false
	}
	n, err := strconv.Atoi(v[:len(v)-1])
	if err != nil {
		return 0, false
	}
	switch v[len(v)-1] {
	case 's':
		return n, true
	case 'm':
		return n * 60, true
	case 'h':
		return n * 3600, true
	case 'd':
		return n * 86400, true
	default:
		return 0, false
	}
}

// Like tpgresource.DurationDiffSuppress, but supports 'd'
func durationDiffSuppress(k, oldr, newr string, d *schema.ResourceData) bool {
	oldSeconds, ok := parseDurationAsSeconds(oldr)
	if !ok {
		return false
	}
	newSeconds, ok := parseDurationAsSeconds(newr)
	if !ok {
		return false
	}
	return oldSeconds == newSeconds
}

func mapHashID(v any) int {
	replaceNestedValue(v, []string{"condition", "older_than"}, expandDuration)
	replaceNestedValue(v, []string{"condition", "newer_than"}, expandDuration)
	return schema.HashString(fmt.Sprintf("%v", v))
}

func expandDuration(v any) (any, bool) {
	if val, ok := v.(string); ok {
		if secs, ok := parseDurationAsSeconds(val); ok {
			return fmt.Sprintf("%ds", secs), true
		}
	}
	return nil, false

}

// Replace a value in a schema object, if it exists.
// Nested maps follow the pattern map[string]any -> [1]any -> map[string]any
func replaceNestedValue(obj any, keys []string, replaceFunc func(any) (any, bool)) {
	if len(keys) == 0 {
		return
	}
	next := obj
	for _, key := range keys[:len(keys)-1] {
		nextMap, ok := next.(map[string]any)
		if !ok {
			return
		}
		arrObj, ok := nextMap[key]
		if !ok {
			return
		}
		arr, ok := arrObj.([]any)
		if !ok {
			return
		}
		if len(arr) != 1 {
			return
		}
		next = arr[0]
	}
	lastMap, ok := next.(map[string]any)
	if !ok {
		return
	}
	lastKey := keys[len(keys)-1]
	last, ok := lastMap[lastKey]
	if !ok {
		return
	}
	result, ok := replaceFunc(last)
	if ok {
		lastMap[lastKey] = result
	}
}

func isDefaultEnum(val any) bool {
	s, ok := val.(string)
	if !ok {
		return false
	}
	return s == "" || strings.HasSuffix(s, "_UNSPECIFIED")
}

// emptyMavenConfigDiffSuppress generates a config from defaults if it or any
// properties are unset. Missing, empty and default configs are all equivalent.
func emptyMavenConfigDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	oSnap, nSnap := d.GetChange("maven_config.0.allow_snapshot_overwrites")
	if oSnap.(bool) != nSnap.(bool) {
		return false
	}
	oPolicy, nPolicy := d.GetChange("maven_config.0.version_policy")
	return isDefaultEnum(oPolicy) && isDefaultEnum(nPolicy)
}

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = fmt.Sprintf
	_ = log.Print
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = schema.Noop
	_ = structure.NormalizeJsonString
	_ = validation.All
	_ = tgcresource.RemoveTerraformAttributionLabel
	_ = tpgresource.GetRegion
	_ = transport_tpg.Config{}
	_ = verify.ProjectRegex
)

const ArtifactRegistryRepositoryAssetType string = "artifactregistry.googleapis.com/Repository"

const ArtifactRegistryRepositorySchemaName string = "google_artifact_registry_repository"

func ResourceArtifactRegistryRepository() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"format": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CaseDiffSuppress,
				Description: `The format of packages that are stored in the repository. Supported formats
can be found [here](https://cloud.google.com/artifact-registry/docs/supported-formats).
You can only create alpha formats if you are a member of the
[alpha user group](https://cloud.google.com/artifact-registry/docs/supported-formats#alpha-access).`,
			},
			"repository_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The last part of the repository name, for example:
"repo1"`,
			},
			"cleanup_policies": {
				Type:     schema.TypeSet,
				Optional: true,
				Description: `Cleanup policies for this repository. Cleanup policies indicate when
certain package versions can be automatically deleted.
Map keys are policy IDs supplied by users during policy creation. They must
unique within a repository and be under 128 characters in length.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:     schema.TypeString,
							Required: true,
						},
						"action": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"DELETE", "KEEP", ""}),
							Description:  `Policy action. Possible values: ["DELETE", "KEEP"]`,
						},
						"condition": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Policy condition for matching versions.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"newer_than": {
										Type:             schema.TypeString,
										Optional:         true,
										DiffSuppressFunc: durationDiffSuppress,
										Description:      `Match versions newer than a duration.`,
									},
									"older_than": {
										Type:             schema.TypeString,
										Optional:         true,
										DiffSuppressFunc: durationDiffSuppress,
										Description:      `Match versions older than a duration.`,
									},
									"package_name_prefixes": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Match versions by package prefix. Applied on any prefix match.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"tag_prefixes": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Match versions by tag prefix. Applied on any prefix match.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"tag_state": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"TAGGED", "UNTAGGED", "ANY", ""}),
										Description:  `Match versions by tag status. Default value: "ANY" Possible values: ["TAGGED", "UNTAGGED", "ANY"]`,
										Default:      "ANY",
									},
									"version_name_prefixes": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Match versions by version name prefix. Applied on any prefix match.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"most_recent_versions": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Policy condition for retaining a minimum number of versions. May only be
specified with a Keep action.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"keep_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Minimum number of versions to keep.`,
									},
									"package_name_prefixes": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Match versions by package prefix. Applied on any prefix match.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
					},
				},
				Set: mapHashID,
			},
			"cleanup_policy_dry_run": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `If true, the cleanup pipeline is prevented from deleting versions in this
repository.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The user-provided description of the repository.`,
			},
			"docker_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Docker repository config contains repository level configuration for the repositories of docker type.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"immutable_tags": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `The repository which enabled this flag prevents all tags from being modified, moved or deleted. This does not prevent tags from being created.`,
						},
					},
				},
			},
			"kms_key_name": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `The Cloud KMS resource name of the customer managed encryption key thatâ€™s
used to encrypt the contents of the Repository. Has the form:
'projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key'.
This value may not be changed after the Repository has been created.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Labels with user-defined metadata.
This field may contain up to 64 entries. Label keys and values may be no
longer than 63 characters. Label keys must begin with a lowercase letter
and may only contain lowercase letters, numeric characters, underscores,
and dashes.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"location": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				ForceNew: true,
				Description: `The name of the repository's location. In addition to specific regions,
special values for multi-region locations are 'asia', 'europe', and 'us'.
See [here](https://cloud.google.com/artifact-registry/docs/repositories/repo-locations),
or use the
[google_artifact_registry_locations](https://registry.terraform.io/providers/hashicorp/google/latest/docs/data-sources/artifact_registry_locations)
data source for possible values.`,
			},
			"maven_config": {
				Type:             schema.TypeList,
				Optional:         true,
				DiffSuppressFunc: emptyMavenConfigDiffSuppress,
				Description: `MavenRepositoryConfig is maven related repository details.
Provides additional configuration details for repositories of the maven
format type.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"allow_snapshot_overwrites": {
							Type:     schema.TypeBool,
							Optional: true,
							ForceNew: true,
							Description: `The repository with this flag will allow publishing the same
snapshot versions.`,
						},
						"version_policy": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"VERSION_POLICY_UNSPECIFIED", "RELEASE", "SNAPSHOT", ""}),
							Description:  `Version policy defines the versions that the registry will accept. Default value: "VERSION_POLICY_UNSPECIFIED" Possible values: ["VERSION_POLICY_UNSPECIFIED", "RELEASE", "SNAPSHOT"]`,
							Default:      "VERSION_POLICY_UNSPECIFIED",
						},
					},
				},
			},
			"mode": {
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"STANDARD_REPOSITORY", "VIRTUAL_REPOSITORY", "REMOTE_REPOSITORY", ""}),
				Description:  `The mode configures the repository to serve artifacts from different sources. Default value: "STANDARD_REPOSITORY" Possible values: ["STANDARD_REPOSITORY", "VIRTUAL_REPOSITORY", "REMOTE_REPOSITORY"]`,
				Default:      "STANDARD_REPOSITORY",
			},
			"remote_repository_config": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Configuration specific for a Remote Repository.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"apt_repository": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Specific settings for an Apt remote repository.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"public_repository": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `One of the publicly available Apt repositories supported by Artifact Registry.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"repository_base": {
													Type:         schema.TypeString,
													Required:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"DEBIAN", "UBUNTU", "DEBIAN_SNAPSHOT"}),
													Description:  `A common public repository base for Apt, e.g. '"debian/dists/stable"' Possible values: ["DEBIAN", "UBUNTU", "DEBIAN_SNAPSHOT"]`,
												},
												"repository_path": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `Specific repository from the base.`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"remote_repository_config.0.apt_repository", "remote_repository_config.0.docker_repository", "remote_repository_config.0.maven_repository", "remote_repository_config.0.npm_repository", "remote_repository_config.0.python_repository", "remote_repository_config.0.yum_repository", "remote_repository_config.0.common_repository"},
						},
						"common_repository": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Specific settings for an Artifact Registory remote repository.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"uri": {
										Type:     schema.TypeString,
										Required: true,
										ForceNew: true,
										Description: `One of:
a. Artifact Registry Repository resource, e.g. 'projects/UPSTREAM_PROJECT_ID/locations/REGION/repositories/UPSTREAM_REPOSITORY'
b. URI to the registry, e.g. '"https://registry-1.docker.io"'
c. URI to Artifact Registry Repository, e.g. '"https://REGION-docker.pkg.dev/UPSTREAM_PROJECT_ID/UPSTREAM_REPOSITORY"'`,
									},
								},
							},
							ExactlyOneOf: []string{"remote_repository_config.0.apt_repository", "remote_repository_config.0.docker_repository", "remote_repository_config.0.maven_repository", "remote_repository_config.0.npm_repository", "remote_repository_config.0.python_repository", "remote_repository_config.0.yum_repository", "remote_repository_config.0.common_repository"},
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							ForceNew:    true,
							Description: `The description of the remote source.`,
						},
						"disable_upstream_validation": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `If true, the remote repository upstream and upstream credentials will
not be validated.`,
						},
						"docker_repository": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Specific settings for a Docker remote repository.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"custom_repository": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `[Deprecated, please use commonRepository instead] Settings for a remote repository with a custom uri.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"uri": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Specific uri to the registry, e.g. '"https://registry-1.docker.io"'`,
												},
											},
										},
										ConflictsWith: []string{"remote_repository_config.0.docker_repository.0.public_repository"},
									},
									"public_repository": {
										Type:          schema.TypeString,
										Optional:      true,
										ForceNew:      true,
										ValidateFunc:  verify.ValidateEnum([]string{"DOCKER_HUB", ""}),
										Description:   `Address of the remote repository. Possible values: ["DOCKER_HUB"]`,
										ConflictsWith: []string{"remote_repository_config.0.docker_repository.0.custom_repository"},
									},
								},
							},
							ExactlyOneOf: []string{"remote_repository_config.0.apt_repository", "remote_repository_config.0.docker_repository", "remote_repository_config.0.maven_repository", "remote_repository_config.0.npm_repository", "remote_repository_config.0.python_repository", "remote_repository_config.0.yum_repository", "remote_repository_config.0.common_repository"},
						},
						"maven_repository": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Specific settings for a Maven remote repository.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"custom_repository": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `[Deprecated, please use commonRepository instead] Settings for a remote repository with a custom uri.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"uri": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Specific uri to the registry, e.g. '"https://repo.maven.apache.org/maven2"'`,
												},
											},
										},
										ConflictsWith: []string{"remote_repository_config.0.maven_repository.0.public_repository"},
									},
									"public_repository": {
										Type:          schema.TypeString,
										Optional:      true,
										ForceNew:      true,
										ValidateFunc:  verify.ValidateEnum([]string{"MAVEN_CENTRAL", ""}),
										Description:   `Address of the remote repository. Possible values: ["MAVEN_CENTRAL"]`,
										ConflictsWith: []string{"remote_repository_config.0.maven_repository.0.custom_repository"},
									},
								},
							},
							ExactlyOneOf: []string{"remote_repository_config.0.apt_repository", "remote_repository_config.0.docker_repository", "remote_repository_config.0.maven_repository", "remote_repository_config.0.npm_repository", "remote_repository_config.0.python_repository", "remote_repository_config.0.yum_repository", "remote_repository_config.0.common_repository"},
						},
						"npm_repository": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Specific settings for an Npm remote repository.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"custom_repository": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `[Deprecated, please use commonRepository instead] Settings for a remote repository with a custom uri.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"uri": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Specific uri to the registry, e.g. '"https://registry.npmjs.org"'`,
												},
											},
										},
										ConflictsWith: []string{"remote_repository_config.0.npm_repository.0.public_repository"},
									},
									"public_repository": {
										Type:          schema.TypeString,
										Optional:      true,
										ForceNew:      true,
										ValidateFunc:  verify.ValidateEnum([]string{"NPMJS", ""}),
										Description:   `Address of the remote repository. Possible values: ["NPMJS"]`,
										ConflictsWith: []string{"remote_repository_config.0.npm_repository.0.custom_repository"},
									},
								},
							},
							ExactlyOneOf: []string{"remote_repository_config.0.apt_repository", "remote_repository_config.0.docker_repository", "remote_repository_config.0.maven_repository", "remote_repository_config.0.npm_repository", "remote_repository_config.0.python_repository", "remote_repository_config.0.yum_repository", "remote_repository_config.0.common_repository"},
						},
						"python_repository": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Specific settings for a Python remote repository.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"custom_repository": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `[Deprecated, please use commonRepository instead] Settings for a remote repository with a custom uri.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"uri": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Specific uri to the registry, e.g. '"https://pypi.io"'`,
												},
											},
										},
										ConflictsWith: []string{"remote_repository_config.0.python_repository.0.public_repository"},
									},
									"public_repository": {
										Type:          schema.TypeString,
										Optional:      true,
										ForceNew:      true,
										ValidateFunc:  verify.ValidateEnum([]string{"PYPI", ""}),
										Description:   `Address of the remote repository. Possible values: ["PYPI"]`,
										ConflictsWith: []string{"remote_repository_config.0.python_repository.0.custom_repository"},
									},
								},
							},
							ExactlyOneOf: []string{"remote_repository_config.0.apt_repository", "remote_repository_config.0.docker_repository", "remote_repository_config.0.maven_repository", "remote_repository_config.0.npm_repository", "remote_repository_config.0.python_repository", "remote_repository_config.0.yum_repository", "remote_repository_config.0.common_repository"},
						},
						"upstream_credentials": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `The credentials used to access the remote repository.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"username_password_credentials": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Use username and password to access the remote repository.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"password_secret_version": {
													Type:     schema.TypeString,
													Optional: true,
													ForceNew: true,
													Description: `The Secret Manager key version that holds the password to access the
remote repository. Must be in the format of
'projects/{project}/secrets/{secret}/versions/{version}'.`,
												},
												"username": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `The username to access the remote repository.`,
												},
											},
										},
									},
								},
							},
						},
						"yum_repository": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Specific settings for an Yum remote repository.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"public_repository": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `One of the publicly available Yum repositories supported by Artifact Registry.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"repository_base": {
													Type:         schema.TypeString,
													Required:     true,
													ForceNew:     true,
													ValidateFunc: verify.ValidateEnum([]string{"CENTOS", "CENTOS_DEBUG", "CENTOS_VAULT", "CENTOS_STREAM", "ROCKY", "EPEL"}),
													Description:  `A common public repository base for Yum. Possible values: ["CENTOS", "CENTOS_DEBUG", "CENTOS_VAULT", "CENTOS_STREAM", "ROCKY", "EPEL"]`,
												},
												"repository_path": {
													Type:        schema.TypeString,
													Required:    true,
													ForceNew:    true,
													Description: `Specific repository from the base, e.g. '"pub/rocky/9/BaseOS/x86_64/os"'`,
												},
											},
										},
									},
								},
							},
							ExactlyOneOf: []string{"remote_repository_config.0.apt_repository", "remote_repository_config.0.docker_repository", "remote_repository_config.0.maven_repository", "remote_repository_config.0.npm_repository", "remote_repository_config.0.python_repository", "remote_repository_config.0.yum_repository", "remote_repository_config.0.common_repository"},
						},
					},
				},
				ConflictsWith: []string{"virtual_repository_config"},
			},
			"virtual_repository_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Configuration specific for a Virtual Repository.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"upstream_policies": {
							Type:             schema.TypeList,
							Optional:         true,
							DiffSuppressFunc: upstreamPoliciesDiffSuppress,
							Description: `Policies that configure the upstream artifacts distributed by the Virtual
Repository. Upstream policies cannot be set on a standard repository.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The user-provided ID of the upstream policy.`,
									},
									"priority": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Entries with a greater priority value take precedence in the pull order.`,
									},
									"repository": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `A reference to the repository resource, for example:
"projects/p1/locations/us-central1/repository/repo1".`,
									},
								},
							},
						},
					},
				},
				ConflictsWith: []string{"remote_repository_config"},
			},
			"vulnerability_scanning_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Configuration for vulnerability scanning of artifacts stored in this repository.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enablement_config": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"INHERITED", "DISABLED", ""}),
							Description:  `This configures whether vulnerability scanning is automatically performed for artifacts pushed to this repository. Possible values: ["INHERITED", "DISABLED"]`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time when the repository was created.`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The name of the repository, for example:
"repo1"`,
			},
			"registry_uri": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The repository endpoint, for example: us-docker.pkg.dev/my-proj/my-repo.`,
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time when the repository was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}
