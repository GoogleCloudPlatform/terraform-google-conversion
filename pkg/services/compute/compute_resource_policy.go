// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/compute/ResourcePolicy.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/tgc_next/services/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package compute

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"reflect"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/tgcresource"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/tpgresource"
	transport_tpg "github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/transport"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/verify"
)

// Suppresses a diff on cases like 1:00 when it should be 01:00.
// Because API will normalize this value
func HourlyFormatSuppressDiff(_, old, new string, _ *schema.ResourceData) bool {
	return old == "0"+new
}

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = fmt.Sprintf
	_ = log.Print
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = schema.Noop
	_ = structure.NormalizeJsonString
	_ = validation.All
	_ = tgcresource.RemoveTerraformAttributionLabel
	_ = tpgresource.GetRegion
	_ = transport_tpg.Config{}
	_ = verify.ProjectRegex
)

const ComputeResourcePolicyAssetType string = "compute.googleapis.com/ResourcePolicy"

const ComputeResourcePolicySchemaName string = "google_compute_resource_policy"

func ResourceComputeResourcePolicy() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"name": {
				Type:     schema.TypeString,
				Required: true,
				Description: `The name of the resource, provided by the client when initially creating
the resource. The resource name must be 1-63 characters long, and comply
with RFC1035. Specifically, the name must be 1-63 characters long and
match the regular expression '[a-z]([-a-z0-9]*[a-z0-9])'? which means the
first character must be a lowercase letter, and all following characters
must be a dash, lowercase letter, or digit, except the last character,
which cannot be a dash.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional description of this resource. Provide this property when you create the resource.`,
			},
			"disk_consistency_group_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Replication consistency group for asynchronous disk replication.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"enabled": {
							Type:        schema.TypeBool,
							Required:    true,
							ForceNew:    true,
							Description: `Enable disk consistency on the resource policy.`,
						},
					},
				},
				ConflictsWith: []string{"group_placement_policy", "instance_schedule_policy", "snapshot_schedule_policy"},
			},
			"group_placement_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Resource policy for instances used for placement configuration.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"availability_domain_count": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `The number of availability domains instances will be spread across. If two instances are in different
availability domain, they will not be put in the same low latency network`,
						},
						"collocation": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"COLLOCATED", ""}),
							Description: `Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
Specify 'COLLOCATED' to enable collocation. Can only be specified with 'vm_count'. If compute instances are created
with a COLLOCATED policy, then exactly 'vm_count' instances must be created at the same time with the resource policy
attached. Possible values: ["COLLOCATED"]`,
						},
						"gpu_topology": {
							Type:          schema.TypeString,
							Optional:      true,
							ForceNew:      true,
							Description:   `Specifies the shape of the GPU slice, in slice based GPU families eg. A4X.`,
							ConflictsWith: []string{},
						},
						"vm_count": {
							Type:     schema.TypeInt,
							Optional: true,
							Description: `Number of VMs in this placement group. Google does not recommend that you use this field
unless you use a compact policy and you want your policy to work only if it contains this
exact number of VMs.`,
						},
					},
				},
				ConflictsWith: []string{"disk_consistency_group_policy", "instance_schedule_policy", "snapshot_schedule_policy"},
			},
			"instance_schedule_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Resource policy for scheduling instance operations.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"time_zone": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Specifies the time zone to be used in interpreting the schedule. The value of this field must be a time zone name
from the tz database: http://en.wikipedia.org/wiki/Tz_database.`,
						},
						"expiration_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The expiration time of the schedule. The timestamp is an RFC3339 string.`,
						},
						"start_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The start time of the schedule. The timestamp is an RFC3339 string.`,
						},
						"vm_start_schedule": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Specifies the schedule for starting instances.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"schedule": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Specifies the frequency for the operation, using the unix-cron format.`,
									},
								},
							},
							AtLeastOneOf: []string{"instance_schedule_policy.0.vm_start_schedule", "instance_schedule_policy.0.vm_stop_schedule"},
						},
						"vm_stop_schedule": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Specifies the schedule for stopping instances.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"schedule": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Specifies the frequency for the operation, using the unix-cron format.`,
									},
								},
							},
							AtLeastOneOf: []string{"instance_schedule_policy.0.vm_start_schedule", "instance_schedule_policy.0.vm_stop_schedule"},
						},
					},
				},
				ConflictsWith: []string{"disk_consistency_group_policy", "group_placement_policy", "snapshot_schedule_policy"},
			},
			"region": {
				Type:             schema.TypeString,
				Computed:         true,
				Optional:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `Region where resource policy resides.`,
			},
			"snapshot_schedule_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Policy for creating snapshots of persistent disks.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"schedule": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Contains one of an 'hourlySchedule', 'dailySchedule', or 'weeklySchedule'.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"daily_schedule": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The policy will execute every nth day at the specified time.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"days_in_cycle": {
													Type:        schema.TypeInt,
													Required:    true,
													Description: `Defines a schedule with units measured in days. The value determines how many days pass between the start of each cycle. Days in cycle for snapshot schedule policy must be 1.`,
												},
												"start_time": {
													Type:             schema.TypeString,
													Required:         true,
													ValidateFunc:     verify.ValidateHourlyOnly,
													DiffSuppressFunc: HourlyFormatSuppressDiff,
													Description: `This must be in UTC format that resolves to one of
00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example,
both 13:00-5 and 08:00 are valid.`,
												},
											},
										},
										ExactlyOneOf: []string{"snapshot_schedule_policy.0.schedule.0.daily_schedule", "snapshot_schedule_policy.0.schedule.0.hourly_schedule", "snapshot_schedule_policy.0.schedule.0.weekly_schedule"},
									},
									"hourly_schedule": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The policy will execute every nth hour starting at the specified time.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"hours_in_cycle": {
													Type:        schema.TypeInt,
													Required:    true,
													Description: `The number of hours between snapshots.`,
												},
												"start_time": {
													Type:             schema.TypeString,
													Required:         true,
													ValidateFunc:     verify.ValidateHourlyOnly,
													DiffSuppressFunc: HourlyFormatSuppressDiff,
													Description: `Time within the window to start the operations.
It must be in an hourly format "HH:MM",
where HH : [00-23] and MM : [00] GMT. eg: 21:00`,
												},
											},
										},
										ExactlyOneOf: []string{"snapshot_schedule_policy.0.schedule.0.daily_schedule", "snapshot_schedule_policy.0.schedule.0.hourly_schedule", "snapshot_schedule_policy.0.schedule.0.weekly_schedule"},
									},
									"weekly_schedule": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Allows specifying a snapshot time for each day of the week.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"day_of_weeks": {
													Type:        schema.TypeSet,
													Required:    true,
													Description: `May contain up to seven (one for each day of the week) snapshot times.`,
													MinItems:    1,
													MaxItems:    7,
													Elem:        computeResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeksSchema(),
													// Default schema.HashSchema is used.
												},
											},
										},
										ExactlyOneOf: []string{"snapshot_schedule_policy.0.schedule.0.daily_schedule", "snapshot_schedule_policy.0.schedule.0.hourly_schedule", "snapshot_schedule_policy.0.schedule.0.weekly_schedule"},
									},
								},
							},
						},
						"retention_policy": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Retention policy applied to snapshots created by this resource policy.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"max_retention_days": {
										Type:        schema.TypeInt,
										Required:    true,
										Description: `Maximum age of the snapshot that is allowed to be kept.`,
									},
									"on_source_disk_delete": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"KEEP_AUTO_SNAPSHOTS", "APPLY_RETENTION_POLICY", ""}),
										Description: `Specifies the behavior to apply to scheduled snapshots when
the source disk is deleted. Default value: "KEEP_AUTO_SNAPSHOTS" Possible values: ["KEEP_AUTO_SNAPSHOTS", "APPLY_RETENTION_POLICY"]`,
										Default: "KEEP_AUTO_SNAPSHOTS",
									},
								},
							},
						},
						"snapshot_properties": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Properties with which the snapshots are created, such as labels.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"chain_name": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `Creates the new snapshot in the snapshot chain labeled with the
specified name. The chain name must be 1-63 characters long and comply
with RFC1035.`,
									},
									"guest_flush": {
										Type:         schema.TypeBool,
										Optional:     true,
										Description:  `Whether to perform a 'guest aware' snapshot.`,
										AtLeastOneOf: []string{"snapshot_schedule_policy.0.snapshot_properties.0.guest_flush", "snapshot_schedule_policy.0.snapshot_properties.0.labels", "snapshot_schedule_policy.0.snapshot_properties.0.storage_locations"},
									},
									"labels": {
										Type:         schema.TypeMap,
										Optional:     true,
										Description:  `A set of key-value pairs.`,
										Elem:         &schema.Schema{Type: schema.TypeString},
										AtLeastOneOf: []string{"snapshot_schedule_policy.0.snapshot_properties.0.guest_flush", "snapshot_schedule_policy.0.snapshot_properties.0.labels", "snapshot_schedule_policy.0.snapshot_properties.0.storage_locations"},
									},
									"storage_locations": {
										Type:     schema.TypeSet,
										Optional: true,
										Description: `Cloud Storage bucket location to store the auto snapshot
(regional or multi-regional)`,
										MaxItems: 1,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
										Set:          schema.HashString,
										AtLeastOneOf: []string{"snapshot_schedule_policy.0.snapshot_properties.0.guest_flush", "snapshot_schedule_policy.0.snapshot_properties.0.labels", "snapshot_schedule_policy.0.snapshot_properties.0.storage_locations"},
									},
								},
							},
						},
					},
				},
				ConflictsWith: []string{"disk_consistency_group_policy", "group_placement_policy", "instance_schedule_policy"},
			},
			"workload_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Represents the workload policy.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"type": {
							Type:         schema.TypeString,
							Required:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"HIGH_AVAILABILITY", "HIGH_THROUGHPUT"}),
							Description:  `The type of workload policy. Possible values: ["HIGH_AVAILABILITY", "HIGH_THROUGHPUT"]`,
						},
						"accelerator_topology": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `The accelerator topology. This field can be set only when the workload policy type is HIGH_THROUGHPUT
and cannot be set if max topology distance is set.`,
							ConflictsWith: []string{"workload_policy.0.max_topology_distance"},
						},
						"max_topology_distance": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"BLOCK", "CLUSTER", "SUBBLOCK", ""}),
							Description: `The maximum topology distance. This field can be set only when the workload policy type is HIGH_THROUGHPUT
and cannot be set if accelerator topology is set. Possible values: ["BLOCK", "CLUSTER", "SUBBLOCK"]`,
							ConflictsWith: []string{"workload_policy.0.accelerator_topology"},
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"self_link": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
		UseJSONNumber: true,
	}
}

func computeResourcePolicySnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeksSchema() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"day": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: verify.ValidateEnum([]string{"MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"}),
				Description:  `The day of the week to create the snapshot. e.g. MONDAY Possible values: ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]`,
			},
			"start_time": {
				Type:     schema.TypeString,
				Required: true,
				Description: `Time within the window to start the operations.
It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.`,
			},
		},
	}
}
