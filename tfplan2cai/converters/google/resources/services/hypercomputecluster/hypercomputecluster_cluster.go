// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/hypercomputecluster/Cluster.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/tgc/resource_converter.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package hypercomputecluster

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"reflect"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/logging"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/tfplan2cai/converters/google/resources/cai"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"

	"google.golang.org/api/googleapi"
)

func resourceHypercomputeclusterClusterResourceHash(v interface{}) int {
	var buf bytes.Buffer
	m := v.(map[string]interface{})
	if v, ok := m["id"]; ok {
		buf.WriteString(fmt.Sprintf("%s-", v.(string)))
	}
	return schema.HashString(buf.String())
}

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = base64.StdEncoding
	_ = fmt.Sprintf
	_ = json.Marshal
	_ = log.Print
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = slices.Min([]int{1})
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = time.Now
	_ = diag.Diagnostic{}
	_ = customdiff.All
	_ = id.UniqueId
	_ = logging.LogLevel
	_ = retry.Retry
	_ = schema.Noop
	_ = structure.ExpandJsonFromString
	_ = validation.All
	_ = terraform.State{}
	_ = tpgresource.SetLabels
	_ = transport_tpg.Config{}
	_ = verify.ProjectRegex
	_ = googleapi.Error{}
)

const HypercomputeclusterClusterAssetType string = "hypercomputecluster.googleapis.com/Cluster"

func ResourceConverterHypercomputeclusterCluster() cai.ResourceConverter {
	return cai.ResourceConverter{
		AssetType: HypercomputeclusterClusterAssetType,
		Convert:   GetHypercomputeclusterClusterCaiObject,
	}
}

func GetHypercomputeclusterClusterCaiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) ([]cai.Asset, error) {
	name, err := cai.AssetName(d, config, "//hypercomputecluster.googleapis.com/projects/{{project}}/locations/{{location}}/clusters/{{cluster_id}}")
	if err != nil {
		return []cai.Asset{}, err
	}
	if obj, err := GetHypercomputeclusterClusterApiObject(d, config); err == nil {
		return []cai.Asset{{
			Name: name,
			Type: HypercomputeclusterClusterAssetType,
			Resource: &cai.AssetResource{
				Version:              "v1beta",
				DiscoveryDocumentURI: "https://www.googleapis.com/discovery/v1/apis/hypercomputecluster/v1beta/rest",
				DiscoveryName:        "Cluster",
				Data:                 obj,
			},
		}}, nil
	} else {
		return []cai.Asset{}, err
	}
}

func GetHypercomputeclusterClusterApiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	obj := make(map[string]interface{})
	computeResourcesProp, err := expandHypercomputeclusterClusterComputeResources(d.Get("compute_resources"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("compute_resources"); !tpgresource.IsEmptyValue(reflect.ValueOf(computeResourcesProp)) && (ok || !reflect.DeepEqual(v, computeResourcesProp)) {
		obj["computeResources"] = computeResourcesProp
	}
	descriptionProp, err := expandHypercomputeclusterClusterDescription(d.Get("description"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	networkResourcesProp, err := expandHypercomputeclusterClusterNetworkResources(d.Get("network_resources"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("network_resources"); !tpgresource.IsEmptyValue(reflect.ValueOf(networkResourcesProp)) && (ok || !reflect.DeepEqual(v, networkResourcesProp)) {
		obj["networkResources"] = networkResourcesProp
	}
	orchestratorProp, err := expandHypercomputeclusterClusterOrchestrator(d.Get("orchestrator"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("orchestrator"); !tpgresource.IsEmptyValue(reflect.ValueOf(orchestratorProp)) && (ok || !reflect.DeepEqual(v, orchestratorProp)) {
		obj["orchestrator"] = orchestratorProp
	}
	storageResourcesProp, err := expandHypercomputeclusterClusterStorageResources(d.Get("storage_resources"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("storage_resources"); !tpgresource.IsEmptyValue(reflect.ValueOf(storageResourcesProp)) && (ok || !reflect.DeepEqual(v, storageResourcesProp)) {
		obj["storageResources"] = storageResourcesProp
	}
	effectiveLabelsProp, err := expandHypercomputeclusterClusterEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(effectiveLabelsProp)) && (ok || !reflect.DeepEqual(v, effectiveLabelsProp)) {
		obj["labels"] = effectiveLabelsProp
	}

	return obj, nil
}

func expandHypercomputeclusterClusterComputeResources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedConfig, err := expandHypercomputeclusterClusterComputeResourcesConfig(original["config"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["config"] = transformedConfig
		}

		transformedId, err := tpgresource.ExpandString(original["id"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedId] = transformed
	}
	return m, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNewFlexStartInstances, err := expandHypercomputeclusterClusterComputeResourcesConfigNewFlexStartInstances(original["new_flex_start_instances"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNewFlexStartInstances); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["newFlexStartInstances"] = transformedNewFlexStartInstances
	}

	transformedNewOnDemandInstances, err := expandHypercomputeclusterClusterComputeResourcesConfigNewOnDemandInstances(original["new_on_demand_instances"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNewOnDemandInstances); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["newOnDemandInstances"] = transformedNewOnDemandInstances
	}

	transformedNewReservedInstances, err := expandHypercomputeclusterClusterComputeResourcesConfigNewReservedInstances(original["new_reserved_instances"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNewReservedInstances); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["newReservedInstances"] = transformedNewReservedInstances
	}

	transformedNewSpotInstances, err := expandHypercomputeclusterClusterComputeResourcesConfigNewSpotInstances(original["new_spot_instances"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNewSpotInstances); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["newSpotInstances"] = transformedNewSpotInstances
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewFlexStartInstances(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMachineType, err := expandHypercomputeclusterClusterComputeResourcesConfigNewFlexStartInstancesMachineType(original["machine_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMachineType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["machineType"] = transformedMachineType
	}

	transformedMaxDuration, err := expandHypercomputeclusterClusterComputeResourcesConfigNewFlexStartInstancesMaxDuration(original["max_duration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxDuration); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxDuration"] = transformedMaxDuration
	}

	transformedZone, err := expandHypercomputeclusterClusterComputeResourcesConfigNewFlexStartInstancesZone(original["zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zone"] = transformedZone
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewFlexStartInstancesMachineType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewFlexStartInstancesMaxDuration(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewFlexStartInstancesZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewOnDemandInstances(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMachineType, err := expandHypercomputeclusterClusterComputeResourcesConfigNewOnDemandInstancesMachineType(original["machine_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMachineType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["machineType"] = transformedMachineType
	}

	transformedZone, err := expandHypercomputeclusterClusterComputeResourcesConfigNewOnDemandInstancesZone(original["zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zone"] = transformedZone
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewOnDemandInstancesMachineType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewOnDemandInstancesZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewReservedInstances(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedReservation, err := expandHypercomputeclusterClusterComputeResourcesConfigNewReservedInstancesReservation(original["reservation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReservation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["reservation"] = transformedReservation
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewReservedInstancesReservation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewSpotInstances(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMachineType, err := expandHypercomputeclusterClusterComputeResourcesConfigNewSpotInstancesMachineType(original["machine_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMachineType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["machineType"] = transformedMachineType
	}

	transformedTerminationAction, err := expandHypercomputeclusterClusterComputeResourcesConfigNewSpotInstancesTerminationAction(original["termination_action"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTerminationAction); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["terminationAction"] = transformedTerminationAction
	}

	transformedZone, err := expandHypercomputeclusterClusterComputeResourcesConfigNewSpotInstancesZone(original["zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zone"] = transformedZone
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewSpotInstancesMachineType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewSpotInstancesTerminationAction(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterComputeResourcesConfigNewSpotInstancesZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterNetworkResources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedConfig, err := expandHypercomputeclusterClusterNetworkResourcesConfig(original["config"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["config"] = transformedConfig
		}

		transformedNetwork, err := expandHypercomputeclusterClusterNetworkResourcesNetwork(original["network"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["network"] = transformedNetwork
		}

		transformedId, err := tpgresource.ExpandString(original["id"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedId] = transformed
	}
	return m, nil
}

func expandHypercomputeclusterClusterNetworkResourcesConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedExistingNetwork, err := expandHypercomputeclusterClusterNetworkResourcesConfigExistingNetwork(original["existing_network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExistingNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["existingNetwork"] = transformedExistingNetwork
	}

	transformedNewNetwork, err := expandHypercomputeclusterClusterNetworkResourcesConfigNewNetwork(original["new_network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNewNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["newNetwork"] = transformedNewNetwork
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterNetworkResourcesConfigExistingNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNetwork, err := expandHypercomputeclusterClusterNetworkResourcesConfigExistingNetworkNetwork(original["network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["network"] = transformedNetwork
	}

	transformedSubnetwork, err := expandHypercomputeclusterClusterNetworkResourcesConfigExistingNetworkSubnetwork(original["subnetwork"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSubnetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["subnetwork"] = transformedSubnetwork
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterNetworkResourcesConfigExistingNetworkNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterNetworkResourcesConfigExistingNetworkSubnetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterNetworkResourcesConfigNewNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandHypercomputeclusterClusterNetworkResourcesConfigNewNetworkDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedNetwork, err := expandHypercomputeclusterClusterNetworkResourcesConfigNewNetworkNetwork(original["network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["network"] = transformedNetwork
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterNetworkResourcesConfigNewNetworkDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterNetworkResourcesConfigNewNetworkNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterNetworkResourcesNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNetwork, err := expandHypercomputeclusterClusterNetworkResourcesNetworkNetwork(original["network"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["network"] = transformedNetwork
	}

	transformedSubnetwork, err := expandHypercomputeclusterClusterNetworkResourcesNetworkSubnetwork(original["subnetwork"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSubnetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["subnetwork"] = transformedSubnetwork
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterNetworkResourcesNetworkNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterNetworkResourcesNetworkSubnetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestrator(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSlurm, err := expandHypercomputeclusterClusterOrchestratorSlurm(original["slurm"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSlurm); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["slurm"] = transformedSlurm
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurm(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDefaultPartition, err := expandHypercomputeclusterClusterOrchestratorSlurmDefaultPartition(original["default_partition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefaultPartition); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["defaultPartition"] = transformedDefaultPartition
	}

	transformedEpilogBashScripts, err := expandHypercomputeclusterClusterOrchestratorSlurmEpilogBashScripts(original["epilog_bash_scripts"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEpilogBashScripts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["epilogBashScripts"] = transformedEpilogBashScripts
	}

	transformedLoginNodes, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodes(original["login_nodes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLoginNodes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["loginNodes"] = transformedLoginNodes
	}

	transformedNodeSets, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSets(original["node_sets"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNodeSets); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nodeSets"] = transformedNodeSets
	}

	transformedPartitions, err := expandHypercomputeclusterClusterOrchestratorSlurmPartitions(original["partitions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPartitions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["partitions"] = transformedPartitions
	}

	transformedPrologBashScripts, err := expandHypercomputeclusterClusterOrchestratorSlurmPrologBashScripts(original["prolog_bash_scripts"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrologBashScripts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["prologBashScripts"] = transformedPrologBashScripts
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmDefaultPartition(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmEpilogBashScripts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBootDisk, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesBootDisk(original["boot_disk"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBootDisk); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bootDisk"] = transformedBootDisk
	}

	transformedCount, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesCount(original["count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["count"] = transformedCount
	}

	transformedEnableOsLogin, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesEnableOsLogin(original["enable_os_login"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnableOsLogin); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enableOsLogin"] = transformedEnableOsLogin
	}

	transformedEnablePublicIps, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesEnablePublicIps(original["enable_public_ips"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnablePublicIps); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enablePublicIps"] = transformedEnablePublicIps
	}

	transformedInstances, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesInstances(original["instances"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstances); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instances"] = transformedInstances
	}

	transformedLabels, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedMachineType, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesMachineType(original["machine_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMachineType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["machineType"] = transformedMachineType
	}

	transformedStartupScript, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesStartupScript(original["startup_script"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartupScript); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startupScript"] = transformedStartupScript
	}

	transformedStorageConfigs, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesStorageConfigs(original["storage_configs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStorageConfigs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["storageConfigs"] = transformedStorageConfigs
	}

	transformedZone, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesZone(original["zone"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedZone); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["zone"] = transformedZone
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesBootDisk(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSizeGb, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesBootDiskSizeGb(original["size_gb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sizeGb"] = transformedSizeGb
	}

	transformedType, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesBootDiskType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesBootDiskSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesBootDiskType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesEnableOsLogin(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesEnablePublicIps(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesInstances(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInstance, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesInstancesInstance(original["instance"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["instance"] = transformedInstance
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesInstancesInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesMachineType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesStartupScript(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesStorageConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedId, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesStorageConfigsId(original["id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["id"] = transformedId
		}

		transformedLocalMount, err := expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesStorageConfigsLocalMount(original["local_mount"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLocalMount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["localMount"] = transformedLocalMount
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesStorageConfigsId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesStorageConfigsLocalMount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmLoginNodesZone(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSets(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedComputeId, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeId(original["compute_id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedComputeId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["computeId"] = transformedComputeId
		}

		transformedComputeInstance, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstance(original["compute_instance"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedComputeInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["computeInstance"] = transformedComputeInstance
		}

		transformedId, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsId(original["id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["id"] = transformedId
		}

		transformedMaxDynamicNodeCount, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsMaxDynamicNodeCount(original["max_dynamic_node_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMaxDynamicNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["maxDynamicNodeCount"] = transformedMaxDynamicNodeCount
		}

		transformedStaticNodeCount, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsStaticNodeCount(original["static_node_count"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStaticNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["staticNodeCount"] = transformedStaticNodeCount
		}

		transformedStorageConfigs, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsStorageConfigs(original["storage_configs"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStorageConfigs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["storageConfigs"] = transformedStorageConfigs
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBootDisk, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceBootDisk(original["boot_disk"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBootDisk); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bootDisk"] = transformedBootDisk
	}

	transformedLabels, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedStartupScript, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceStartupScript(original["startup_script"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartupScript); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startupScript"] = transformedStartupScript
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceBootDisk(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSizeGb, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceBootDiskSizeGb(original["size_gb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSizeGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sizeGb"] = transformedSizeGb
	}

	transformedType, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceBootDiskType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceBootDiskSizeGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceBootDiskType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsComputeInstanceStartupScript(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsMaxDynamicNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsStaticNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsStorageConfigs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedId, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsStorageConfigsId(original["id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["id"] = transformedId
		}

		transformedLocalMount, err := expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsStorageConfigsLocalMount(original["local_mount"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLocalMount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["localMount"] = transformedLocalMount
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsStorageConfigsId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmNodeSetsStorageConfigsLocalMount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmPartitions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedId, err := expandHypercomputeclusterClusterOrchestratorSlurmPartitionsId(original["id"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["id"] = transformedId
		}

		transformedNodeSetIds, err := expandHypercomputeclusterClusterOrchestratorSlurmPartitionsNodeSetIds(original["node_set_ids"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNodeSetIds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["nodeSetIds"] = transformedNodeSetIds
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmPartitionsId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmPartitionsNodeSetIds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterOrchestratorSlurmPrologBashScripts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedBucket, err := expandHypercomputeclusterClusterStorageResourcesBucket(original["bucket"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["bucket"] = transformedBucket
		}

		transformedConfig, err := expandHypercomputeclusterClusterStorageResourcesConfig(original["config"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["config"] = transformedConfig
		}

		transformedFilestore, err := expandHypercomputeclusterClusterStorageResourcesFilestore(original["filestore"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFilestore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["filestore"] = transformedFilestore
		}

		transformedLustre, err := expandHypercomputeclusterClusterStorageResourcesLustre(original["lustre"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLustre); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["lustre"] = transformedLustre
		}

		transformedId, err := tpgresource.ExpandString(original["id"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedId] = transformed
	}
	return m, nil
}

func expandHypercomputeclusterClusterStorageResourcesBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBucket, err := expandHypercomputeclusterClusterStorageResourcesBucketBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesBucketBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedExistingBucket, err := expandHypercomputeclusterClusterStorageResourcesConfigExistingBucket(original["existing_bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExistingBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["existingBucket"] = transformedExistingBucket
	}

	transformedExistingFilestore, err := expandHypercomputeclusterClusterStorageResourcesConfigExistingFilestore(original["existing_filestore"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExistingFilestore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["existingFilestore"] = transformedExistingFilestore
	}

	transformedExistingLustre, err := expandHypercomputeclusterClusterStorageResourcesConfigExistingLustre(original["existing_lustre"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExistingLustre); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["existingLustre"] = transformedExistingLustre
	}

	transformedNewBucket, err := expandHypercomputeclusterClusterStorageResourcesConfigNewBucket(original["new_bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNewBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["newBucket"] = transformedNewBucket
	}

	transformedNewFilestore, err := expandHypercomputeclusterClusterStorageResourcesConfigNewFilestore(original["new_filestore"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNewFilestore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["newFilestore"] = transformedNewFilestore
	}

	transformedNewLustre, err := expandHypercomputeclusterClusterStorageResourcesConfigNewLustre(original["new_lustre"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNewLustre); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["newLustre"] = transformedNewLustre
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigExistingBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBucket, err := expandHypercomputeclusterClusterStorageResourcesConfigExistingBucketBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigExistingBucketBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigExistingFilestore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFilestore, err := expandHypercomputeclusterClusterStorageResourcesConfigExistingFilestoreFilestore(original["filestore"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFilestore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["filestore"] = transformedFilestore
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigExistingFilestoreFilestore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigExistingLustre(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLustre, err := expandHypercomputeclusterClusterStorageResourcesConfigExistingLustreLustre(original["lustre"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLustre); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["lustre"] = transformedLustre
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigExistingLustreLustre(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAutoclass, err := expandHypercomputeclusterClusterStorageResourcesConfigNewBucketAutoclass(original["autoclass"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAutoclass); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["autoclass"] = transformedAutoclass
	}

	transformedBucket, err := expandHypercomputeclusterClusterStorageResourcesConfigNewBucketBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	transformedHierarchicalNamespace, err := expandHypercomputeclusterClusterStorageResourcesConfigNewBucketHierarchicalNamespace(original["hierarchical_namespace"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHierarchicalNamespace); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["hierarchicalNamespace"] = transformedHierarchicalNamespace
	}

	transformedStorageClass, err := expandHypercomputeclusterClusterStorageResourcesConfigNewBucketStorageClass(original["storage_class"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStorageClass); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["storageClass"] = transformedStorageClass
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewBucketAutoclass(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandHypercomputeclusterClusterStorageResourcesConfigNewBucketAutoclassEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewBucketAutoclassEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewBucketBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewBucketHierarchicalNamespace(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEnabled, err := expandHypercomputeclusterClusterStorageResourcesConfigNewBucketHierarchicalNamespaceEnabled(original["enabled"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["enabled"] = transformedEnabled
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewBucketHierarchicalNamespaceEnabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewBucketStorageClass(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewFilestore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDescription, err := expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedFileShares, err := expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreFileShares(original["file_shares"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFileShares); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["fileShares"] = transformedFileShares
	}

	transformedFilestore, err := expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreFilestore(original["filestore"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFilestore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["filestore"] = transformedFilestore
	}

	transformedProtocol, err := expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreProtocol(original["protocol"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProtocol); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["protocol"] = transformedProtocol
	}

	transformedTier, err := expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreTier(original["tier"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTier); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tier"] = transformedTier
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreFileShares(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedCapacityGb, err := expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreFileSharesCapacityGb(original["capacity_gb"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCapacityGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["capacityGb"] = transformedCapacityGb
		}

		transformedFileShare, err := expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreFileSharesFileShare(original["file_share"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFileShare); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["fileShare"] = transformedFileShare
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreFileSharesCapacityGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreFileSharesFileShare(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreFilestore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreProtocol(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewFilestoreTier(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewLustre(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCapacityGb, err := expandHypercomputeclusterClusterStorageResourcesConfigNewLustreCapacityGb(original["capacity_gb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCapacityGb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["capacityGb"] = transformedCapacityGb
	}

	transformedDescription, err := expandHypercomputeclusterClusterStorageResourcesConfigNewLustreDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedFilesystem, err := expandHypercomputeclusterClusterStorageResourcesConfigNewLustreFilesystem(original["filesystem"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFilesystem); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["filesystem"] = transformedFilesystem
	}

	transformedLustre, err := expandHypercomputeclusterClusterStorageResourcesConfigNewLustreLustre(original["lustre"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLustre); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["lustre"] = transformedLustre
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewLustreCapacityGb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewLustreDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewLustreFilesystem(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesConfigNewLustreLustre(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesFilestore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedFilestore, err := expandHypercomputeclusterClusterStorageResourcesFilestoreFilestore(original["filestore"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFilestore); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["filestore"] = transformedFilestore
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesFilestoreFilestore(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterStorageResourcesLustre(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLustre, err := expandHypercomputeclusterClusterStorageResourcesLustreLustre(original["lustre"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLustre); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["lustre"] = transformedLustre
	}

	return transformed, nil
}

func expandHypercomputeclusterClusterStorageResourcesLustreLustre(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandHypercomputeclusterClusterEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
