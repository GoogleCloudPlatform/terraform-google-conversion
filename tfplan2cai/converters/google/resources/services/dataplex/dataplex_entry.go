// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/dataplex/Entry.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/tgc/resource_converter.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package dataplex

import (
	"encoding/json"
	"fmt"
	"reflect"
	"regexp"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/tfplan2cai/converters/google/resources/cai"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

// GetEntry supports up to 100 aspects. Therefore we set a threshold at 99.
const maxAspectNumber = 99

// NumberOfAspectsValidation checks if the number of aspects on an entry exceeds certain threshold.
func NumberOfAspectsValidation(i interface{}, k string) (warnings []string, errors []error) {
	s, isSlice := i.([]interface{})
	m, isMap := i.(map[string]interface{})

	if !isSlice && !isMap {
		errors = append(errors, fmt.Errorf("expected type of field %q to be array, but got %T", k, i))
		return warnings, errors
	}

	if len(s)+len(m) > maxAspectNumber {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid content: %q. The maximal number of aspects is 99.",
			k, i,
		))
	}

	return warnings, errors
}

// ProjectNumberValidation checks if the input string conforms to the pattern:
// "projects/<project-number>/<anything>"
func ProjectNumberValidation(i interface{}, k string) (warnings []string, errors []error) {
	v, ok := i.(string)

	if !ok {
		errors = append(errors, fmt.Errorf("expected type of field %q to be string, but got %T", k, i))
		return warnings, errors
	}

	var projectNumberRegex = regexp.MustCompile(`^projects\/[1-9]\d*\/.+$`)
	if !projectNumberRegex.MatchString(v) {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid format: %q. Expected format: 'projects/<project-number>/<anything>'. Please note that project IDs are not supported.",
			k, v,
		))
	}

	return warnings, errors
}

// ProjectNumberValidation checks if the input string conforms to the pattern:
// "projects/<project-number>/<anything>"
func AspectProjectNumberValidation(i interface{}, k string) (warnings []string, errors []error) {
	v, ok := i.(string)
	if !ok {
		errors = append(errors, fmt.Errorf("expected type of field %q to be string, but got %T", k, i))
		return warnings, errors
	}

	var numberDotAnythingRegex = regexp.MustCompile(`^[1-9]\d*\..+$`)

	if !numberDotAnythingRegex.MatchString(v) {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid format: %q. Expected format: '<project number>.anything'. Please note that project IDs are not supported.",
			k, v,
		))
	}

	return warnings, errors
}

// FilterAspects filters the aspects in res based on aspectKeySet.
// It returns an error if type assertions fail.
func FilterAspects(aspectKeySet map[string]struct{}, res map[string]interface{}) error {
	aspectsRaw, ok := res["aspects"]
	if !ok || aspectsRaw == nil {
		return nil
	}

	aspectsMap, ok := aspectsRaw.(map[string]interface{})
	if !ok {
		return fmt.Errorf("FilterAspects: 'aspects' field is not a map[string]interface{}, got %T", aspectsRaw)
	}

	for key := range aspectsMap {
		if _, keep := aspectKeySet[key]; !keep {
			delete(aspectsMap, key)
		}
	}
	return nil
}

// AddAspectsToSet adds aspect keys from the aspects interface to the aspectKeySet.
// It returns an error if type assertions fail or expected keys are missing.
func AddAspectsToSet(aspectKeySet map[string]struct{}, aspects interface{}) error {
	if aspects == nil {
		return nil
	}
	aspectsSlice, ok := aspects.([]interface{})
	if !ok {
		return fmt.Errorf("AddAspectsToSet: input 'aspects' is not a []interface{}, got %T", aspects)
	}

	for i, aspectItemRaw := range aspectsSlice {
		aspectMap, ok := aspectItemRaw.(map[string]interface{})
		if !ok {
			return fmt.Errorf("AddAspectsToSet: item at index %d is not a map[string]interface{}, got %T", i, aspectItemRaw)
		}

		keyRaw, keyExists := aspectMap["aspect_key"]
		if !keyExists {
			return fmt.Errorf("AddAspectsToSet: 'aspect_key' not found in aspect item at index %d", i)
		}

		keyString, ok := keyRaw.(string)
		if !ok {
			return fmt.Errorf("AddAspectsToSet: 'aspect_key' in item at index %d is not a string, got %T", i, keyRaw)
		}
		aspectKeySet[keyString] = struct{}{}
	}
	return nil
}

// InverseTransformAspects converts the "aspects" map back to a slice of maps,
// re-inserting the "aspectKey". Modifies obj in-place.
// It returns an error if type assertions fail.
func InverseTransformAspects(res map[string]interface{}) error {
	aspectsRaw, ok := res["aspects"]
	if !ok || aspectsRaw == nil {
		return nil
	}

	originalMap, ok := aspectsRaw.(map[string]interface{})
	if !ok {
		return fmt.Errorf("InverseTransformAspects: 'aspects' field is not a map[string]interface{}, got %T", aspectsRaw)
	}

	newSlice := make([]interface{}, 0, len(originalMap))

	for key, value := range originalMap {
		innerMap, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("InverseTransformAspects: value for key '%s' is not a map[string]interface{}, got %T", key, value)
		}
		box := make(map[string]interface{}, 2)
		box["aspectKey"] = key
		box["aspect"] = innerMap
		newSlice = append(newSlice, box)
	}
	res["aspects"] = newSlice
	return nil
}

// TransformAspects concisely transforms the "aspects" slice within obj into a map.
// Modifies obj in-place.
// It returns an error if type assertions fail or expected keys are missing.
func TransformAspects(obj map[string]interface{}) error {
	aspectsRaw, ok := obj["aspects"]
	if !ok || aspectsRaw == nil {
		return nil
	}

	originalSlice, ok := aspectsRaw.([]interface{})
	if !ok {
		return fmt.Errorf("TransformAspects: 'aspects' field is not a []interface{}, got %T", aspectsRaw)
	}

	newMap := make(map[string]interface{}, len(originalSlice))
	for i, item := range originalSlice {
		aspectMap, ok := item.(map[string]interface{})
		if !ok {
			return fmt.Errorf("TransformAspects: item in 'aspects' slice at index %d is not a map[string]interface{}, got %T", i, item)
		}

		keyRaw, keyExists := aspectMap["aspectKey"]
		if !keyExists {
			return fmt.Errorf("TransformAspects: 'aspectKey' not found in aspect item at index %d", i)
		}
		key, ok := keyRaw.(string)
		if !ok {
			return fmt.Errorf("TransformAspects: 'aspectKey' in item at index %d is not a string, got %T", i, keyRaw)
		}

		valueRaw, valueExists := aspectMap["aspect"]
		if !valueExists {
			newMap[key] = map[string]interface{}{"data": map[string]interface{}{}}
			continue
		}

		value, ok := valueRaw.(map[string]interface{})
		if ok {
			newMap[key] = value
		} else {
			newMap[key] = map[string]interface{}{"data": map[string]interface{}{}}
		}
	}
	obj["aspects"] = newMap
	return nil
}

const DataplexEntryAssetType string = "dataplex.googleapis.com/Entry"

func ResourceConverterDataplexEntry() cai.ResourceConverter {
	return cai.ResourceConverter{
		AssetType: DataplexEntryAssetType,
		Convert:   GetDataplexEntryCaiObject,
	}
}

func GetDataplexEntryCaiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) ([]cai.Asset, error) {
	name, err := cai.AssetName(d, config, "//dataplex.googleapis.com/projects/{{project}}/locations/{{location}}/entryGroups/{{entry_group_id}}/entries/{{entry_id}}")
	if err != nil {
		return []cai.Asset{}, err
	}
	if obj, err := GetDataplexEntryApiObject(d, config); err == nil {
		return []cai.Asset{{
			Name: name,
			Type: DataplexEntryAssetType,
			Resource: &cai.AssetResource{
				Version:              "v1",
				DiscoveryDocumentURI: "https://www.googleapis.com/discovery/v1/apis/dataplex/v1/rest",
				DiscoveryName:        "Entry",
				Data:                 obj,
			},
		}}, nil
	} else {
		return []cai.Asset{}, err
	}
}

func GetDataplexEntryApiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	obj := make(map[string]interface{})
	entryTypeProp, err := expandDataplexEntryEntryType(d.Get("entry_type"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("entry_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(entryTypeProp)) && (ok || !reflect.DeepEqual(v, entryTypeProp)) {
		obj["entryType"] = entryTypeProp
	}
	aspectsProp, err := expandDataplexEntryAspects(d.Get("aspects"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("aspects"); !tpgresource.IsEmptyValue(reflect.ValueOf(aspectsProp)) && (ok || !reflect.DeepEqual(v, aspectsProp)) {
		obj["aspects"] = aspectsProp
	}
	parentEntryProp, err := expandDataplexEntryParentEntry(d.Get("parent_entry"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("parent_entry"); !tpgresource.IsEmptyValue(reflect.ValueOf(parentEntryProp)) && (ok || !reflect.DeepEqual(v, parentEntryProp)) {
		obj["parentEntry"] = parentEntryProp
	}
	fullyQualifiedNameProp, err := expandDataplexEntryFullyQualifiedName(d.Get("fully_qualified_name"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("fully_qualified_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(fullyQualifiedNameProp)) && (ok || !reflect.DeepEqual(v, fullyQualifiedNameProp)) {
		obj["fullyQualifiedName"] = fullyQualifiedNameProp
	}
	entrySourceProp, err := expandDataplexEntryEntrySource(d.Get("entry_source"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("entry_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(entrySourceProp)) && (ok || !reflect.DeepEqual(v, entrySourceProp)) {
		obj["entrySource"] = entrySourceProp
	}

	return resourceDataplexEntryEncoder(d, config, obj)
}

func resourceDataplexEntryEncoder(d tpgresource.TerraformResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	// The yaml file does not allow validation for Array fields.
	// Therefore we add validation as a part of the encoding proecess.
	aspects := obj["aspects"]
	if aspects != nil {
		_, errors := NumberOfAspectsValidation(aspects, "aspects")
		if len(errors) > 0 {
			return nil, errors[0]
		}
	}

	err := TransformAspects(obj)

	if err != nil {
		return nil, err
	}

	return obj, nil
}

func expandDataplexEntryEntryType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspects(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAspectKey, err := expandDataplexEntryAspectsAspectKey(original["aspect_key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAspectKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["aspectKey"] = transformedAspectKey
		}

		transformedAspect, err := expandDataplexEntryAspectsAspect(original["aspect"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAspect); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["aspect"] = transformedAspect
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDataplexEntryAspectsAspectKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspect(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAspectType, err := expandDataplexEntryAspectsAspectAspectType(original["aspect_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAspectType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["aspectType"] = transformedAspectType
	}

	transformedPath, err := expandDataplexEntryAspectsAspectPath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedCreateTime, err := expandDataplexEntryAspectsAspectCreateTime(original["create_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["createTime"] = transformedCreateTime
	}

	transformedUpdateTime, err := expandDataplexEntryAspectsAspectUpdateTime(original["update_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUpdateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["updateTime"] = transformedUpdateTime
	}

	transformedData, err := expandDataplexEntryAspectsAspectData(original["data"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedData); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["data"] = transformedData
	}

	return transformed, nil
}

func expandDataplexEntryAspectsAspectAspectType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectCreateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectUpdateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectData(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	m := make(map[string]interface{})
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return m, nil
}

func expandDataplexEntryParentEntry(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryFullyQualifiedName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedResource, err := expandDataplexEntryEntrySourceResource(original["resource"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resource"] = transformedResource
	}

	transformedSystem, err := expandDataplexEntryEntrySourceSystem(original["system"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSystem); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["system"] = transformedSystem
	}

	transformedPlatform, err := expandDataplexEntryEntrySourcePlatform(original["platform"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPlatform); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["platform"] = transformedPlatform
	}

	transformedDisplayName, err := expandDataplexEntryEntrySourceDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedDescription, err := expandDataplexEntryEntrySourceDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedLabels, err := expandDataplexEntryEntrySourceLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedAncestors, err := expandDataplexEntryEntrySourceAncestors(original["ancestors"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAncestors); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ancestors"] = transformedAncestors
	}

	transformedCreateTime, err := expandDataplexEntryEntrySourceCreateTime(original["create_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["createTime"] = transformedCreateTime
	}

	transformedUpdateTime, err := expandDataplexEntryEntrySourceUpdateTime(original["update_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUpdateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["updateTime"] = transformedUpdateTime
	}

	transformedLocation, err := expandDataplexEntryEntrySourceLocation(original["location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["location"] = transformedLocation
	}

	return transformed, nil
}

func expandDataplexEntryEntrySourceResource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceSystem(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourcePlatform(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandDataplexEntryEntrySourceAncestors(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandDataplexEntryEntrySourceAncestorsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedType, err := expandDataplexEntryEntrySourceAncestorsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDataplexEntryEntrySourceAncestorsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceAncestorsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceCreateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceUpdateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
