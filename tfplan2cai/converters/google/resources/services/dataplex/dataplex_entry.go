// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/dataplex/Entry.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/tgc/resource_converter.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package dataplex

import (
	"encoding/json"
	"fmt"
	"reflect"
	"regexp"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v6/tfplan2cai/converters/google/resources/cai"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

// GetEntry supports up to 100 aspects. Therefore we set a threshold at 99.
const maxAspectNumber = 99

// NumberOfAspectsValidation checks if the number of aspects on an entry exceeds certain threshold.
func NumberOfAspectsValidation(i interface{}, k string) (warnings []string, errors []error) {
	s, isSlice := i.([]interface{})
	m, isMap := i.(map[string]interface{})

	if !isSlice && !isMap {
		errors = append(errors, fmt.Errorf("expected type of field %q to be array, but got %T", k, i))
		return warnings, errors
	}

	if len(s)+len(m) > maxAspectNumber {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid content: %q. The maximal number of aspects is 99.",
			k, i,
		))
	}

	return warnings, errors
}

// ProjectNumberValidation checks if the input string conforms to the pattern:
// "projects/<project-number>/<anything>"
func ProjectNumberValidation(i interface{}, k string) (warnings []string, errors []error) {
	v, ok := i.(string)

	if !ok {
		errors = append(errors, fmt.Errorf("expected type of field %q to be string, but got %T", k, i))
		return warnings, errors
	}

	var projectNumberRegex = regexp.MustCompile(`^projects\/[1-9]\d*\/.+$`)
	if !projectNumberRegex.MatchString(v) {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid format: %q. Expected format: 'projects/<project-number>/<anything>'. Please note that project IDs are not supported.",
			k, v,
		))
	}

	return warnings, errors
}

// ProjectNumberValidation checks if the input string conforms to the pattern:
// "projects/<project-number>/<anything>"
func AspectProjectNumberValidation(i interface{}, k string) (warnings []string, errors []error) {
	v, ok := i.(string)
	if !ok {
		errors = append(errors, fmt.Errorf("expected type of field %q to be string, but got %T", k, i))
		return warnings, errors
	}

	var numberDotAnythingRegex = regexp.MustCompile(`^[1-9]\d*\..+$`)

	if !numberDotAnythingRegex.MatchString(v) {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid format: %q. Expected format: '<project number>.anything'. Please note that project IDs are not supported.",
			k, v,
		))
	}

	return warnings, errors
}

func FilterAspects(aspectKeySet map[string]struct{}, res map[string]interface{}) {
	if res["aspects"] == nil {
		return
	}
	aspectsMap := res["aspects"].(map[string]interface{})
	for key := range aspectsMap {
		if _, keep := aspectKeySet[key]; !keep {
			delete(aspectsMap, key)
		}
	}
}

func AddAspectsToSet(aspectKeySet map[string]struct{}, aspects interface{}) {
	for _, aspectItemRaw := range aspects.([]interface{}) {
		aspectMap := aspectItemRaw.(map[string]interface{})
		keyString := aspectMap["aspect_key"].(string)
		aspectKeySet[keyString] = struct{}{}
	}
}

// InverseTransformAspects converts the "aspects" map back to a slice of maps,
// re-inserting the "aspectKey". Modifies obj in-place.
func InverseTransformAspects(res map[string]interface{}) {
	if res["aspects"] == nil {
		return
	}
	originalMap := res["aspects"].(map[string]interface{})
	newSlice := make([]interface{}, 0, len(originalMap))

	for key, value := range originalMap {
		innerMap := value.(map[string]interface{})
		box := make(map[string]interface{}, 2)
		box["aspectKey"] = key
		box["aspectValue"] = innerMap
		newSlice = append(newSlice, box)
	}
	res["aspects"] = newSlice
}

// TransformAspects concisely transforms the "aspects" slice within obj into a map.
// It assumes obj["aspects"] exists and is a []interface{} containing
// map[string]interface{} elements, each with a string "aspectKey".
// Modifies obj in-place.
func TransformAspects(obj map[string]interface{}) {
	if obj["aspects"] == nil {
		return
	}
	originalSlice := obj["aspects"].([]interface{})
	newMap := make(map[string]interface{}, len(originalSlice))
	for _, item := range originalSlice {
		aspectMap := item.(map[string]interface{})

		key := aspectMap["aspectKey"].(string)
		value := aspectMap["aspectValue"].(map[string]interface{})

		newMap[key] = value
	}
	obj["aspects"] = newMap
}

const DataplexEntryAssetType string = "dataplex.googleapis.com/Entry"

func ResourceConverterDataplexEntry() cai.ResourceConverter {
	return cai.ResourceConverter{
		AssetType: DataplexEntryAssetType,
		Convert:   GetDataplexEntryCaiObject,
	}
}

func GetDataplexEntryCaiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) ([]cai.Asset, error) {
	name, err := cai.AssetName(d, config, "//dataplex.googleapis.com/projects/{{project}}/locations/{{location}}/entryGroups/{{entry_group_id}}/entries/{{entry_id}}")
	if err != nil {
		return []cai.Asset{}, err
	}
	if obj, err := GetDataplexEntryApiObject(d, config); err == nil {
		return []cai.Asset{{
			Name: name,
			Type: DataplexEntryAssetType,
			Resource: &cai.AssetResource{
				Version:              "v1",
				DiscoveryDocumentURI: "https://www.googleapis.com/discovery/v1/apis/dataplex/v1/rest",
				DiscoveryName:        "Entry",
				Data:                 obj,
			},
		}}, nil
	} else {
		return []cai.Asset{}, err
	}
}

func GetDataplexEntryApiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	obj := make(map[string]interface{})
	entryTypeProp, err := expandDataplexEntryEntryType(d.Get("entry_type"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("entry_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(entryTypeProp)) && (ok || !reflect.DeepEqual(v, entryTypeProp)) {
		obj["entryType"] = entryTypeProp
	}
	aspectsProp, err := expandDataplexEntryAspects(d.Get("aspects"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("aspects"); !tpgresource.IsEmptyValue(reflect.ValueOf(aspectsProp)) && (ok || !reflect.DeepEqual(v, aspectsProp)) {
		obj["aspects"] = aspectsProp
	}
	parentEntryProp, err := expandDataplexEntryParentEntry(d.Get("parent_entry"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("parent_entry"); !tpgresource.IsEmptyValue(reflect.ValueOf(parentEntryProp)) && (ok || !reflect.DeepEqual(v, parentEntryProp)) {
		obj["parentEntry"] = parentEntryProp
	}
	fullyQualifiedNameProp, err := expandDataplexEntryFullyQualifiedName(d.Get("fully_qualified_name"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("fully_qualified_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(fullyQualifiedNameProp)) && (ok || !reflect.DeepEqual(v, fullyQualifiedNameProp)) {
		obj["fullyQualifiedName"] = fullyQualifiedNameProp
	}
	entrySourceProp, err := expandDataplexEntryEntrySource(d.Get("entry_source"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("entry_source"); !tpgresource.IsEmptyValue(reflect.ValueOf(entrySourceProp)) && (ok || !reflect.DeepEqual(v, entrySourceProp)) {
		obj["entrySource"] = entrySourceProp
	}

	return resourceDataplexEntryEncoder(d, config, obj)
}

func resourceDataplexEntryEncoder(d tpgresource.TerraformResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	// The yaml file does not allow validation for Array fields.
	// Therefore we add validation as a part of the encoding proecess.
	aspects := obj["aspects"]
	if aspects != nil {
		_, errors := NumberOfAspectsValidation(aspects, "aspects")
		if len(errors) > 0 {
			return nil, errors[0]
		}
	}

	TransformAspects(obj)
	return obj, nil
}

func expandDataplexEntryEntryType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspects(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedAspectKey, err := expandDataplexEntryAspectsAspectKey(original["aspect_key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAspectKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["aspectKey"] = transformedAspectKey
		}

		transformedAspectValue, err := expandDataplexEntryAspectsAspectValue(original["aspect_value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAspectValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["aspectValue"] = transformedAspectValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDataplexEntryAspectsAspectKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAspectType, err := expandDataplexEntryAspectsAspectValueAspectType(original["aspect_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAspectType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["aspectType"] = transformedAspectType
	}

	transformedPath, err := expandDataplexEntryAspectsAspectValuePath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedCreateTime, err := expandDataplexEntryAspectsAspectValueCreateTime(original["create_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["createTime"] = transformedCreateTime
	}

	transformedUpdateTime, err := expandDataplexEntryAspectsAspectValueUpdateTime(original["update_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUpdateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["updateTime"] = transformedUpdateTime
	}

	transformedData, err := expandDataplexEntryAspectsAspectValueData(original["data"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedData); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["data"] = transformedData
	}

	return transformed, nil
}

func expandDataplexEntryAspectsAspectValueAspectType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectValuePath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectValueCreateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectValueUpdateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryAspectsAspectValueData(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	b := []byte(v.(string))
	if len(b) == 0 {
		return nil, nil
	}
	m := make(map[string]interface{})
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return m, nil
}

func expandDataplexEntryParentEntry(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryFullyQualifiedName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedResource, err := expandDataplexEntryEntrySourceResource(original["resource"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["resource"] = transformedResource
	}

	transformedSystem, err := expandDataplexEntryEntrySourceSystem(original["system"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSystem); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["system"] = transformedSystem
	}

	transformedPlatform, err := expandDataplexEntryEntrySourcePlatform(original["platform"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPlatform); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["platform"] = transformedPlatform
	}

	transformedDisplayName, err := expandDataplexEntryEntrySourceDisplayName(original["display_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDisplayName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["displayName"] = transformedDisplayName
	}

	transformedDescription, err := expandDataplexEntryEntrySourceDescription(original["description"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDescription); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["description"] = transformedDescription
	}

	transformedLabels, err := expandDataplexEntryEntrySourceLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedAncestors, err := expandDataplexEntryEntrySourceAncestors(original["ancestors"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAncestors); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ancestors"] = transformedAncestors
	}

	transformedCreateTime, err := expandDataplexEntryEntrySourceCreateTime(original["create_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["createTime"] = transformedCreateTime
	}

	transformedUpdateTime, err := expandDataplexEntryEntrySourceUpdateTime(original["update_time"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUpdateTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["updateTime"] = transformedUpdateTime
	}

	transformedLocation, err := expandDataplexEntryEntrySourceLocation(original["location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["location"] = transformedLocation
	}

	return transformed, nil
}

func expandDataplexEntryEntrySourceResource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceSystem(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourcePlatform(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandDataplexEntryEntrySourceAncestors(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandDataplexEntryEntrySourceAncestorsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedType, err := expandDataplexEntryEntrySourceAncestorsType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDataplexEntryEntrySourceAncestorsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceAncestorsType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceCreateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceUpdateTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandDataplexEntryEntrySourceLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
