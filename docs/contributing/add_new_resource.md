# Adding support for converting a new resource

**Note**: terraform-google-conversion evolves from terraform-validator. Hence, the name terraform-validator shows up in various places.

terraform-google-conversion consumes a Terraform plan and uses it to build CAI Assets. These built Assets only exist locally, in memory.

### Getting a terraform resource name from a GCP resource name

The first step in determining if a GCP resource is supported is to figure out the name of the corresponding Terraform resource. You can often do this by searching for the GCP resource name in the [Terraform google-beta provider documentation](https://registry.terraform.io/providers/hashicorp/google-beta/latest/docs).

### Getting canonical representation of a CAI asset

You can run [`gcloud asset list`](https://cloud.google.com/sdk/gcloud/reference/asset/list) to list existing assets and their details. For each asset, the output shows its ancestors, asset type, name, and the last updated time. For example,

```
$ gcloud asset list --project='my-project'
---
ancestors:
- projects/999999
- folders/888888
- organizations/777777
assetType: compute.googleapis.com/Project
name: //compute.googleapis.com/projects/my-project
updateTime: '2022-02-22T22:00:20.265968Z'
...
```
The output can help validate `Name`, `Type`, `Ancestry` attribute of a converted CAI asset.

Note that you may need to create an actual resource in GCP if the asset you would like to list does not exist. Moreover, you will need to have relevant permission to proceed, especially to listing assets in folders and organizations.

## How to add support for a new resource

### tfplan2cai

A resource is "supported" by tfplan2cai conversion if it has an entry in [`tfplan2cai/converters/google/resources/resource_converters.go`](https://github.com/GoogleCloudPlatform/terraform-google-conversion/blob/main/tfplan2cai/converters/google/resources/resource_converters.go). For example, you could search resource_converters.go for [`google_compute_disk`](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_disk) to see if that resource is supported.

Adding support for a resource has 3 steps:

1. Make changes to [Magic Modules](https://github.com/GoogleCloudPlatform/magic-modules) to add or modify resource conversion code.
2. Add tests for the new resource into [Magic Modules](https://github.com/GoogleCloudPlatform/magic-modules).
3. Make PRs for Magic Modules with your changes.

Each of these is discussed in more details below.

#### 1. Magic Modules

Magic Modules uses a shared code base to generate terraform-google-conversion and the [google](https://github.com/hashicorp/terraform-provider-google) and [google-beta](https://github.com/hashicorp/terraform-provider-google-beta) Terraform providers.
Most Terraform resources are represented as [yaml files which are grouped by product](https://github.com/GoogleCloudPlatform/magic-modules/tree/master/mmv1/products).
Each product has an `product.yaml` file (which defines the basic product information) and  Resource.yaml files (which defines any resource-specific information).
A Resource.yaml file can specify `exclude_tgc: true` to skip tfplan2cai converter autogeneration, or `exclude_resource: true` to skip autogeneration for both tfplan2cai converter and the providers.

Auto-generating tfplan2cai code based on yaml files is strongly preferred. If this does not automatically add an entry to `resource_converters.go`, you can manually add an entry to [`resource_converters.go.tmpl`](https://github.com/GoogleCloudPlatform/magic-modules/blob/main/mmv1/third_party/tgc/resource_converters.go.tmpl) using the autogenerated resource converter function.

##### Handwritten converters
If an autogenerated converter is not possible, you can instead place a handwritten file in the specific Product folder in the [`magic-modules/mmv1/third_party/tgc/services` folder](https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/tgc/services).
Most resources will only need a resource converter with a conversion func. For the Resource resource within Product, this might look like:

```golang
// The type comes from https://cloud.google.com/asset-inventory/docs/supported-asset-types
const ProductResourceAssetType string = "whatever.googleapis.com/asset-type"

func resourceConverterProductResource() ResourceConverter {
	return ResourceConverter{
		AssetType: ProductResourceAssetType,
		Convert:   GetProductResourceCaiObject,

	}
}

func GetProductResourceCaiObject(d TerraformResourceData, config *Config) ([]Asset, error) {
	// This function does basic conversion of a Terraform resource to a CAI Asset.
	// The asset path (name) will substitute in variables from the Terraform resource.
	// The format should match what is specified at https://cloud.google.com/asset-inventory/docs/supported-asset-types
	name, err := assetName(d, config, "//whatever.googleapis.com/projects/{{project}}/whatevers/{{name}}")
	if err != nil {
		return []Asset{}, err
	}
	if obj, err := GetProductResourceApiObject(d, config); err == nil {
		return []Asset{{
			Name: name,
			Type: ProductResourceAssetType,
			Resource: &AssetResource{
				Version:              "v1",  // or whatever the correct version is
				DiscoveryDocumentURI: "https://www.googleapis.com/path/to/rest/api/docs",
				DiscoveryName:        "Whatever",  // The term used to refer to this resource by the official documentation
				Data:                 obj,
			},
		}}, nil
	} else {
		return []Asset{}, err
	}
}

func GetProductResourceApiObject(d TerraformResourceData, config *Config) (map[string]interface{}, error) {
	obj := make(map[string]interface{})

	// copy values from the terraform resource to obj
	// return any errors encountered
	// ...

	return obj, nil
}

```

For IAM resources, the resource converter should include IAM policy, IAM member and IAM binding. The convert functions are similar to the above example. In addition, the converter needs to add the merge functions and fetch full resource functions. This might look like


```golang

func resourceConverterProductResourceIamPolicy() ResourceConverter {
	return ResourceConverter{
		// The type comes from https://cloud.google.com/asset-inventory/docs/supported-asset-types
		AssetType:         "whatever.googleapis.com/asset-type",
		Convert:           GetProductResourceIamPolicyCaiObject,
		MergeCreateUpdate: MergeProductResourceIamPolicy,
	}
}

func resourceConverterProductResourceIamMember() ResourceConverter {
	return ResourceConverter{
		// The type comes from https://cloud.google.com/asset-inventory/docs/supported-asset-types
		AssetType:         "whatever.googleapis.com/asset-type",
		Convert:           GetProductResourceIamMemberCaiObject,
		FetchFullResource: FetchProductResourceIamPolicy,
		MergeCreateUpdate: MergeProductResourceIamMember,
		MergeDelete:       MergeProductResourceIamMemberDelete,
	}
}

func resourceConverterProductResourceIamBinding() ResourceConverter {
	return ResourceConverter{
		// The type comes from https://cloud.google.com/asset-inventory/docs/supported-asset-types
		AssetType:         "whatever.googleapis.com/asset-type",
		Convert:           GetProductResourceIamBindingCaiObject,
		FetchFullResource: FetchProductResourceIamPolicy,
		MergeCreateUpdate: MergeProductResourceIamBinding,
		MergeDelete:       MergeProductResourceIamBindingDelete,
	}
}


func MergeProductResourceIamPolicy(existing, incoming Asset) Asset {
	existing.IAMPolicy = incoming.IAMPolicy
	return existing
}

func MergeProductResourceIamBinding(existing, incoming Asset) Asset {
	return mergeIamAssets(existing, incoming, mergeAuthoritativeBindings)
}

func MergeProductResourceIamBindingDelete(existing, incoming Asset) Asset {
	return mergeDeleteIamAssets(existing, incoming, mergeDeleteAuthoritativeBindings)
}

func MergeProductResourceIamMember(existing, incoming Asset) Asset {
	return mergeIamAssets(existing, incoming, mergeAdditiveBindings)
}

func MergeProductResourceIamMemberDelete(existing, incoming Asset) Asset {
	return mergeDeleteIamAssets(existing, incoming, mergeDeleteAdditiveBindings)
}

func FetchProductResourceIamPolicy(d TerraformResourceData, config *Config) (Asset, error) {
	// Check one or more identity fields are available
	if _, ok := d.GetOk("some-identity"); !ok {
		return Asset{}, ErrEmptyIdentityField
	}

	return fetchIamPolicy(
		NewProductResourceApiObjectUpdater,
		d,
		config,
		// Asset name template, the format should match what is specified at https://cloud.google.com/asset-inventory/docs/supported-asset-types
		"//whatever.googleapis.com/projects/{{project}}/whatevers/{{name}}",
		// The type comes from https://cloud.google.com/asset-inventory/docs/supported-asset-types
		"whatever.googleapis.com/asset-type",
	)
}

```

After creating the handwritten file, you will need to add a copy entry in [`magic-modules/mmv1/provider/terraform_tgc.go`](https://github.com/GoogleCloudPlatform/magic-modules/blob/main/mmv1/provider/terraform_tgc.go) specifying the handwritten file path and the desired destination in terraform-google-conversion repository.

If your handwritten file is a `.tmpl` file, add an entry into the `resourceConverters` list inside function `CompileCommonFiles`.

```go
resourceConverters := map[string]string{
  ...
	"converters/google/resources/services/[YOUR-SERVICE]/[YOUR-FILE].go":         "third_party/tgc/services/[YOUR-SERVICE]/[YOUR-FILE].go.tmpl",
  ...
}

```

If your handwritten file is a `.go` file, add an entry into the `resourceConverters` list inside function `CopyCommonFiles`.

```go
resourceConverters := map[string]string{
  ...
  "converters/google/resources/services/[YOUR-SERVICE]/[YOUR-FILE].go":                     "third_party/tgc/services/[YOUR-SERVICE]/[YOUR-FILE].go",
  ...
}

```
You will also need to add an entry to [`resource_converters.go.tmpl`](https://github.com/GoogleCloudPlatform/magic-modules/blob/main/mmv1/third_party/tgc/resource_converters.go.tmpl), which is used to generate [`converters/google/resources/resource_converters.go`](https://github.com/GoogleCloudPlatform/terraform-google-conversion/blob/main/converters/google/resources/resource_converters.go). For IAM resource, you will need to add entries each for IAM policy, IAM binding, and IAM member. Each entry in `resource_converters.go.tmpl` maps a terraform resource name to a function that returns a ResourceConverter - in this case:

```golang
// ...
"google_product_resource": resourceConverterProductResource(),
// ...
```

To generate terraform-google-conversion code locally, run the following from the root of the `magic-modules` repository:

```
make tgc OUTPUT_PATH="/path/to/your/terraform-google-conversion"
```
It might require to install relevant go version for this to run successfully. Follow the [Before you begin](https://googlecloudplatform.github.io/magic-modules/get-started/generate-providers/#before-you-begin) and [Setup your development environment](https://googlecloudplatform.github.io/magic-modules/develop/set-up-dev-environment/) sections from the [Magic Modules documentation](https://googlecloudplatform.github.io/magic-modules/get-started/generate-providers/).

You can then run `make test` inside your terraform-google-conversion repository to make sure that your code compiles and passes basic unit tests. Check [index.md](./index.md) file for more testing instructions.

#### 2. Adding new tests

Terraform google conversion tests require setting up a few files in [`tfplan2cai/testdata/templates`](https://github.com/GoogleCloudPlatform/terraform-google-conversion/tree/main/tfplan2cai/testdata/templates). Using the previous example, these files would be:

- example_product_resource.tf
  - A basic terraform file that creates the minimum resources necessary for the google_product_resource resource.
- example_product_resource.tfplan.json
  - A plan json file generated from example_product_resource.tf. This file should not be checked in to the code base, since it will be regenerated during the test.
- example_product_resource.json
  - The results of running [`tfplan2cai convert example_product_resource.tfplan.json`](./index.md#convert-command)

It's easiest to set up a [test project](https://cloud.google.com/docs/terraform/policy-validation/validate-policies) to create the initial versions of these files. The idea is to use the tfplan2cai binary to invoke a convert operation, and replace the strings specific to your test project in the generated files. The following are typical steps that you can take:

1. Run `make build` to compile the tfplan2cai binary.
2. Create `example_product_resource.tf`, where the content is the resource that you would like to test, and place it in a new folder.
3. Within the new folder, run these commands to get resource files in json format.
```bash
  terraform init
  terraform plan -out=example_product_resource.tfplan
  terraform show -json example_product_resource.tfplan > example_product_resource.tfplan.json
```
4. Using the newly compiled binary, run
```bash
  ./bin/tfplan2cai convert example_product_resource.tfplan.json --project=[YOUR-PROJECT] > example_product_resource.json
```

Once you have initial versions completed, you need to make the following replacements in the .tf and .json (not including the .tfplan.json) files:

1. Test project ancestry => `{{.Ancestry}}/project/{{.Provider.project}}`
1. Test project id (without ancestry) => `{{.Provider.project}}`
1. Test project number => `{{.Project.Number}}`
1. Test organization id => `{{.OrgID}}`
1. Test folder id => `{{.FolderID}}`
1. Test billing account => `{{.Project.BillingAccountName}}`

Add your template test files, eg. `example_product_resource.tf`, `example_product_resource.json` to folder [`magic-modules/mmv1/third_party/tgc/tests/data`](https://github.com/GoogleCloudPlatform/magic-modules/tree/master/mmv1/third_party/tgc/tests/data).

By default, the tests will compare the expected `example_product_resource.json` result with the actual result from the test environment, and fail if they do not match. If you need more control over how matching is done (eg. check that an array contains a value), you can use a custom compare function, and configure the test in [`cli_test.go.tmpl`](https://github.com/GoogleCloudPlatform/magic-modules/blob/main/mmv1/third_party/tgc/tests/source/cli_test.go.tmpl#L31C1-L33C1) and [`read_test.go.tmpl`](https://github.com/GoogleCloudPlatform/magic-modules/blob/main/mmv1/third_party/tgc/tests/source/read_test.go.tmpl#L22C1-L34C1). This is currently being done for `*_iam_member` and `*_iam_binding` resources in order to ignore preexisting permissions in the test environment.

Run the following from the root of the `magic-modules` repository again, it should auto-generate an entry with the name of your files (i.e. `example_product_resource`) to the lists of test cases in [test/cli_test.go](https://github.com/GoogleCloudPlatform/terraform-google-conversion/blob/main/tfplan2cai/test/cli_test.go) and [test/read_test.go](https://github.com/GoogleCloudPlatform/terraform-google-conversion/blob/main/tfplan2cai/test/read_test.go), along with your test files copied to terraform-google-conversion repository.

```
make tgc OUTPUT_PATH="/path/to/your/terraform-google-conversion"
```

Now [run your tests](./index.md#testing) and make sure they pass locally before proceeding. (But you can also go ahead and open PRs if you're running into issues you can't figure out how to resolve.)

Note: The tfplan file is generated using the provider version specified in go.mod file. To get a specific google provider version, go to the tgc folder, and update the modules. For example,

```bash
cd /path/to/your/terraform-google-conversion

go mod edit -replace github.com/hashicorp/terraform-provider-google-beta=github.com/modular-magician/terraform-provider-google-beta@auto-pr-8670
```

#### 3. Make PRs

Now that you have your code working locally, open a PR for [Magic Modules](https://github.com/GoogleCloudPlatform/magic-modules).

For the Magic Modules PR, check the build results within `presubmit-generate-diffs`. Click through the build links, and find the results of `tgc-test`, `tgc-test-integration-*` - the other checks only matter if you're also making changes to the terraform provider.

If the `tgc-test` is failing, make sure you can run the unit tests successfully locally. If any of the `tgc-test-integration-*` is failing, try run the integration test within docker container to verify. The success of the integration often depends on the folder structure of test project as well, in that case there is no good way to debug locally, but try to sort out the diff from the test output.


### cai2hcl

A resource is "supported" by cai2hcl conversion if it has an entry in [`cai2hcl/converter_map.go`](https://github.com/GoogleCloudPlatform/terraform-google-conversion/blob/main/cai2hcl/converter_map.go). For example, you could search converter_map.go for [`google_compute_disk`](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_disk) to see if that resource is supported.

Adding support for a resource has 3 steps:

1. Make changes to [Magic Modules](https://github.com/GoogleCloudPlatform/magic-modules) to add or modify resource conversion code.
2. Add tests for the new resource into [Magic Modules](https://github.com/GoogleCloudPlatform/magic-modules).
3. Make PRs for Magic Modules with your changes.

Each of these is discussed in more details below.

#### 1. Magic Modules

Autogenerated cai2hcl converter is not supported.

##### Handwritten converters
You can place a handwritten file in the specific Product folder in [`magic-modules/mmv1/third_party/cai2hcl/services`](https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/cai2hcl/services) folder.
Most resources will only need a resource converter with a conversion func. For the Resource resource within Product, this might look like:

```golang
// The type comes from https://cloud.google.com/asset-inventory/docs/supported-asset-types
const ProductResourceAssetType string = "whatever.googleapis.com/asset-type"

// ProductResourceSchemaName is the TF resource schema name for the Resource resource within Product.
const ProductResourceSchemaName string = "google_product_resource"

// ProductResourceConverter for the Resource resource within Product.
type ProductResourceConverter struct {
	name   string
	schema map[string]*schema.Schema
}

// NewProductResourceConverter returns an HCL converter for compute instance.
func NewProductResourceConverter(provider *schema.Provider) common.Converter {
	schema := provider.ResourcesMap[ProductResourceSchemaName].Schema

	return &ProductResourceConverter{
		name:   ProductResourceSchemaName,
		schema: schema,
	}
}

// Convert converts asset to HCL resource blocks.
func (c *ProductResourceConverter) Convert(assets []*caiasset.Asset) ([]*common.HCLResourceBlock, error) {
	var blocks []*common.HCLResourceBlock
	for _, asset := range assets {
		if asset == nil {
			continue
		}

		// The IAM policy asset convertion is optional.
		// For IAM asset, the resource converter converts it into the IAM policy resource.
		if asset.IAMPolicy != nil {
			iamBlock, err := c.convertIAM(asset)
			if err != nil {
				return nil, err
			}
			blocks = append(blocks, iamBlock)
		}

		if asset.Resource != nil && asset.Resource.Data != nil {
			block, err := c.convertResourceData(asset)
			if err != nil {
				return nil, err
			}
			blocks = append(blocks, block)
		}
	}
	return blocks, nil
}

func (c *ProductResourceConverter) convertResourceData(asset *caiasset.Asset) (*common.HCLResourceBlock, error) {
	if asset == nil || asset.Resource == nil || asset.Resource.Data == nil {
		return nil, fmt.Errorf("asset resource data is nil")
	}

	hclData := make(map[string]interface{})
	// copy values from the CAI asset to hclData
	// return any errors encountered
	// ...

	ctyVal, err := common.MapToCtyValWithSchema(hclData, c.schema)
	if err != nil {
		return nil, err
	}
	return &common.HCLResourceBlock{
		Labels: []string{c.name, "Whatever"},
		Value:  ctyVal,
	}, nil
}

func (c *ProductResourceConverter) convertIAM(asset *caiasset.Asset) (*common.HCLResourceBlock, error) {
	if asset == nil || asset.IAMPolicy == nil {
		return nil, fmt.Errorf("asset IAM policy is nil")
	}

	// copy values from the CAI asset to hclData
	// return any errors encountered
	// ...

	return &common.HCLResourceBlock{
		Labels: []string{
			c.name + "_iam_policy",
			"Whatever" + "_iam_policy",
		},
		Value: cty.ObjectVal(map[string]cty.Value{
		// ...
		}),
	}, nil
}

```

You will also need to add an entry to [`cai2hcl/converter_map.go`](https://github.com/GoogleCloudPlatform/magic-modules/blob/main/mmv1/third_party/cai2hcl/converter_map.go), which is used to generate [`cai2hcl/converter_map.go`](https://github.com/GoogleCloudPlatform/terraform-google-conversion/blob/main/cai2hcl/converter_map.go).

To generate terraform-google-conversion code locally, run the following from the root of the `magic-modules` repository:

```
make tgc OUTPUT_PATH="/path/to/your/terraform-google-conversion"
```
It might require to install relevant go version for this to run successfully. Follow the [Before you begin](https://googlecloudplatform.github.io/magic-modules/get-started/generate-providers/#before-you-begin) and [Setup your development environment](https://googlecloudplatform.github.io/magic-modules/develop/set-up-dev-environment/) sections from the [Magic Modules documentation](https://googlecloudplatform.github.io/magic-modules/get-started/generate-providers/).

You can then run `make test` inside your terraform-google-conversion repository to make sure that your code compiles and passes basic unit tests. Check [index.md](./index.md) file for more testing instructions.

#### 2. Adding new tests

Terraform google conversion tests require setting up a few files in each product's `testdata` folder in [`magic-modules/mmv1/third_party/cai2hcl/services`](https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/cai2hcl/services) folder. Using the previous example, these files would be:

- example_product_resource.json
  - A basic CAI assets file
- example_product_resource.tf
  - A expected terraform result file  

Add your template test files, eg. `example_product_resource.tf`, `example_product_resource.json` to `testdata` folder inside each product in [`magic-modules/mmv1/third_party/cai2hcl/services`](https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/cai2hcl/services).

By default, the tests will compare the expected `example_product_resource.tf` result with the actual result from the test environment, and fail if they do not match.

Now [run your tests](./index.md#testing) and make sure they pass locally before proceeding. (But you can also go ahead and open PRs if you're running into issues you can't figure out how to resolve.)

Note: The HCL file is generated using the provider version specified in go.mod file. To get a specific google provider version, go to the tgc folder, and update the modules. For example,

```bash
cd /path/to/your/terraform-google-conversion

go mod edit -replace github.com/hashicorp/terraform-provider-google-beta=github.com/modular-magician/terraform-provider-google-beta@auto-pr-8670
```

#### 3. Make PRs

Now that you have your code working locally, open a PR for [Magic Modules](https://github.com/GoogleCloudPlatform/magic-modules).

For the Magic Modules PR, check the build results within `presubmit-generate-diffs`. Click through the build links, and find the results of `tgc-test`, `tgc-test-integration-*` - the other checks only matter if you're also making changes to the terraform provider.

If the `tgc-test` is failing, make sure you can run the unit tests successfully locally. If any of the `tgc-test-integration-*` is failing, try run the integration test within docker container to verify. The success of the integration often depends on the folder structure of test project as well, in that case there is no good way to debug locally, but try to sort out the diff from the test output.

