// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/vpcaccess/Connector.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/tgc_next/services/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package vpcaccess

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"reflect"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/tgcresource"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/tpgresource"
	transport_tpg "github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/transport"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/verify"
)

func isInstanceShrinkage(_ context.Context, old, new, _ interface{}) bool {
	// max and min instances can only increase in-place,
	// so we must create a new resource if it is decreased.
	if old == nil || new == nil {
		return false
	}
	return new.(int) < old.(int)
}

var (
	_ = bytes.Clone
	_ = context.WithCancel
	_ = fmt.Sprintf
	_ = log.Print
	_ = reflect.ValueOf
	_ = regexp.Match
	_ = sort.IntSlice{}
	_ = strconv.Atoi
	_ = strings.Trim
	_ = schema.Noop
	_ = structure.NormalizeJsonString
	_ = validation.All
	_ = tgcresource.RemoveTerraformAttributionLabel
	_ = tpgresource.GetRegion
	_ = transport_tpg.Config{}
	_ = verify.ProjectRegex
)

const VPCAccessConnectorAssetType string = "vpcaccess.googleapis.com/Connector"

const VPCAccessConnectorSchemaName string = "google_vpc_access_connector"

func ResourceVPCAccessConnector() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of the resource (Max 25 characters).`,
			},
			"ip_cidr_range": {
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				Description:  `The range of internal addresses that follows RFC 4632 notation. Example: '10.132.0.0/28'.`,
				RequiredWith: []string{"network"},
			},
			"machine_type": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Machine type of VM Instance underlying connector. Default is e2-micro`,
				Default:     "e2-micro",
			},
			"max_instances": {
				Type:     schema.TypeInt,
				Computed: true,
				Optional: true,
				Description: `Maximum value of instances in autoscaling group underlying the connector. Value must be between 3 and 10, inclusive. Must be
higher than the value specified by min_instances. Required alongside 'min_instances' if not using 'min_throughput'/'max_throughput'.`,
				ConflictsWith: []string{"max_throughput"},
			},
			"max_throughput": {
				Type:         schema.TypeInt,
				Computed:     true,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: validation.IntBetween(200, 1000),
				Description: `Maximum throughput of the connector in Mbps, must be greater than 'min_throughput'. Default is 300. Refers to the expected throughput
when using an e2-micro machine type. Value must be a multiple of 100 from 300 through 1000. Must be higher than the value specified by
min_throughput. Only one of 'max_throughput' and 'max_instances' can be specified. The use of max_throughput is discouraged in favor of max_instances.`,
				ConflictsWith: []string{"max_instances"},
			},
			"min_instances": {
				Type:     schema.TypeInt,
				Computed: true,
				Optional: true,
				Description: `Minimum value of instances in autoscaling group underlying the connector. Value must be between 2 and 9, inclusive. Must be
lower than the value specified by max_instances. Required alongside 'max_instances' if not using 'min_throughput'/'max_throughput'.`,
				ConflictsWith: []string{"min_throughput"},
			},
			"min_throughput": {
				Type:         schema.TypeInt,
				Computed:     true,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: validation.IntBetween(200, 1000),
				Description: `Minimum throughput of the connector in Mbps. Default and min is 200. Refers to the expected throughput when using an e2-micro machine type.
Value must be a multiple of 100 from 200 through 900. Must be lower than the value specified by max_throughput.
Only one of 'min_throughput' and 'min_instances' can be specified. The use of min_throughput is discouraged in favor of min_instances.`,
				ConflictsWith: []string{"min_instances"},
			},
			"network": {
				Type:             schema.TypeString,
				Computed:         true,
				Optional:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareResourceNames,
				Description:      `Name or self_link of the VPC network. Required if 'ip_cidr_range' is set.`,
				ExactlyOneOf:     []string{"network", "subnet.0.name"},
			},
			"region": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `Region where the VPC Access connector resides. If it is not provided, the provider region is used.`,
			},
			"subnet": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `The subnet in which to house the connector`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:     schema.TypeString,
							Optional: true,
							ForceNew: true,
							Description: `Subnet name (relative, not fully qualified). E.g. if the full subnet selfLink is
https://compute.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetName} the correct input for this field would be {subnetName}"`,
							ExactlyOneOf: []string{"network", "subnet.0.name"},
						},
						"project_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Project in which the subnet exists. If not set, this project is assumed to be the project for which the connector create request was issued.`,
						},
					},
				},
			},
			"connected_projects": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `List of projects using the connector.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"self_link": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The fully qualified name of this VPC connector`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `State of the VPC access connector.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}
