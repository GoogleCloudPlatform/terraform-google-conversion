// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/redis/Cluster.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/tgc_next/services/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package redis

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v7/pkg/verify"
)

const RedisClusterAssetType string = "redis.googleapis.com/Cluster"

const RedisClusterSchemaName string = "google_redis_cluster"

func ResourceRedisCluster() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				ForceNew: true,
				Description: `Unique name of the resource in this scope including project and location using the form:
projects/{projectId}/locations/{locationId}/clusters/{clusterId}`,
			},
			"shard_count": {
				Type:        schema.TypeInt,
				Required:    true,
				Description: `Required. Number of shards for the Redis cluster.`,
			},
			"authorization_mode": {
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"AUTH_MODE_UNSPECIFIED", "AUTH_MODE_IAM_AUTH", "AUTH_MODE_DISABLED", ""}),
				Description:  `Optional. The authorization mode of the Redis cluster. If not provided, auth feature is disabled for the cluster. Default value: "AUTH_MODE_DISABLED" Possible values: ["AUTH_MODE_UNSPECIFIED", "AUTH_MODE_IAM_AUTH", "AUTH_MODE_DISABLED"]`,
				Default:      "AUTH_MODE_DISABLED",
			},
			"automated_backup_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The automated backup config for a instance.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"fixed_frequency_schedule": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Trigger automated backups at a fixed frequency.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"start_time": {
										Type:     schema.TypeList,
										Required: true,
										Description: `The start time of every automated backup in UTC.
It must be set to the start of an hour. This field is required.`,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"hours": {
													Type:     schema.TypeInt,
													Required: true,
													Description: `Hours of a day in 24 hour format. Must be greater than or equal to 0 and typically must be less than or equal to 23.
An API may choose to allow the value "24:00:00" for scenarios like business closing time.`,
												},
											},
										},
									},
								},
							},
						},
						"retention": {
							Type:     schema.TypeString,
							Required: true,
							Description: `How long to keep automated backups before the backups are deleted.
The value should be between 1 day and 365 days. If not specified, the default value is 35 days.
A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`,
						},
					},
				},
			},
			"cross_cluster_replication_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Cross cluster replication config`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cluster_role": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"CLUSTER_ROLE_UNSPECIFIED", "NONE", "PRIMARY", "SECONDARY", ""}),
							Description: `The role of the cluster in cross cluster replication. Supported values are:

1. 'CLUSTER_ROLE_UNSPECIFIED': This is an independent cluster that has never participated in cross cluster replication. It allows both reads and writes.

1. 'NONE': This is an independent cluster that previously participated in cross cluster replication(either as a 'PRIMARY' or 'SECONDARY' cluster). It allows both reads and writes.

1. 'PRIMARY': This cluster serves as the replication source for secondary clusters that are replicating from it. Any data written to it is automatically replicated to its secondary clusters. It allows both reads and writes.

1. 'SECONDARY': This cluster replicates data from the primary cluster. It allows only reads. Possible values: ["CLUSTER_ROLE_UNSPECIFIED", "NONE", "PRIMARY", "SECONDARY"]`,
						},
						"primary_cluster": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Details of the primary cluster that is used as the replication source for this secondary cluster. This is allowed to be set only for clusters whose cluster role is of type 'SECONDARY'.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"cluster": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The full resource path of the primary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}`,
									},
								},
							},
						},
						"secondary_clusters": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `List of secondary clusters that are replicating from this primary cluster. This is allowed to be set only for clusters whose cluster role is of type 'PRIMARY'.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"cluster": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The full resource path of the secondary cluster in the format: projects/{project}/locations/{region}/clusters/{cluster-id}`,
									},
								},
							},
						},
					},
				},
			},
			"deletion_protection_enabled": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `Optional. Indicates if the cluster is deletion protected or not.
If the value if set to true, any delete cluster operation will fail.
Default value is true.`,
				Default: true,
			},
			"gcs_source": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Backups stored in Cloud Storage buckets. The Cloud Storage buckets need to be the same region as the clusters.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"uris": {
							Type:        schema.TypeSet,
							Required:    true,
							ForceNew:    true,
							Description: `URIs of the GCS objects to import. Example: gs://bucket1/object1, gs://bucket2/folder2/object2`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Set: schema.HashString,
						},
					},
				},
				ConflictsWith: []string{"managed_backup_source"},
			},
			"kms_key": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The KMS key used to encrypt the at-rest data of the cluster.`,
			},
			"maintenance_policy": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Maintenance policy for a cluster`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"weekly_maintenance_window": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Optional. Maintenance window that is applied to resources covered by this policy.
Minimum 1. For the current version, the maximum number
of weekly_window is expected to be one.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"day": {
										Type:         schema.TypeString,
										Required:     true,
										ValidateFunc: verify.ValidateEnum([]string{"DAY_OF_WEEK_UNSPECIFIED", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"}),
										Description: `Required. The day of week that maintenance updates occur.

- DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
- MONDAY: Monday
- TUESDAY: Tuesday
- WEDNESDAY: Wednesday
- THURSDAY: Thursday
- FRIDAY: Friday
- SATURDAY: Saturday
- SUNDAY: Sunday Possible values: ["DAY_OF_WEEK_UNSPECIFIED", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]`,
									},
									"start_time": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `Required. Start time of the window in UTC time.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"hours": {
													Type:         schema.TypeInt,
													Optional:     true,
													ValidateFunc: validation.IntBetween(0, 23),
													Description: `Hours of day in 24 hour format. Should be from 0 to 23.
An API may choose to allow the value "24:00:00" for scenarios like business closing time.`,
												},
												"minutes": {
													Type:         schema.TypeInt,
													Optional:     true,
													ValidateFunc: validation.IntBetween(0, 59),
													Description:  `Minutes of hour of day. Must be from 0 to 59.`,
												},
												"nanos": {
													Type:         schema.TypeInt,
													Optional:     true,
													ValidateFunc: validation.IntBetween(0, 999999999),
													Description:  `Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.`,
												},
												"seconds": {
													Type:         schema.TypeInt,
													Optional:     true,
													ValidateFunc: validation.IntBetween(0, 60),
													Description: `Seconds of minutes of the time. Must normally be from 0 to 59.
An API may allow the value 60 if it allows leap-seconds.`,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"maintenance_version": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `This field can be used to trigger self service update to indicate the desired maintenance version. The input to this field can be determined by the available_maintenance_versions field.
*Note*: This field can only be specified when updating an existing cluster to a newer version. Downgrades are currently not supported!`,
			},
			"managed_backup_source": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Backups that generated and managed by memorystore.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"backup": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `Example: 'projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup}'.`,
						},
					},
				},
				ConflictsWith: []string{"gcs_source"},
			},
			"node_type": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"REDIS_SHARED_CORE_NANO", "REDIS_HIGHMEM_MEDIUM", "REDIS_HIGHMEM_XLARGE", "REDIS_STANDARD_SMALL", ""}),
				Description: `The nodeType for the Redis cluster.
If not provided, REDIS_HIGHMEM_MEDIUM will be used as default Possible values: ["REDIS_SHARED_CORE_NANO", "REDIS_HIGHMEM_MEDIUM", "REDIS_HIGHMEM_XLARGE", "REDIS_STANDARD_SMALL"]`,
			},
			"persistence_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Persistence config (RDB, AOF) for the cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"aof_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `AOF configuration. This field will be ignored if mode is not AOF.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"append_fsync": {
										Type:         schema.TypeString,
										Computed:     true,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"APPEND_FSYNC_UNSPECIFIED", "NO", "EVERYSEC", "ALWAYS", ""}),
										Description: `Optional. Available fsync modes.

- NO - Do not explicitly call fsync(). Rely on OS defaults.
- EVERYSEC - Call fsync() once per second in a background thread. A balance between performance and durability.
- ALWAYS - Call fsync() for earch write command. Possible values: ["APPEND_FSYNC_UNSPECIFIED", "NO", "EVERYSEC", "ALWAYS"]`,
									},
								},
							},
						},
						"mode": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"PERSISTENCE_MODE_UNSPECIFIED", "DISABLED", "RDB", "AOF", ""}),
							Description: `Optional. Controls whether Persistence features are enabled. If not provided, the existing value will be used.

- DISABLED: 	Persistence (both backup and restore) is disabled for the cluster.
- RDB: RDB based Persistence is enabled.
- AOF: AOF based Persistence is enabled. Possible values: ["PERSISTENCE_MODE_UNSPECIFIED", "DISABLED", "RDB", "AOF"]`,
						},
						"rdb_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `RDB configuration. This field will be ignored if mode is not RDB.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"rdb_snapshot_period": {
										Type:         schema.TypeString,
										Computed:     true,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"SNAPSHOT_PERIOD_UNSPECIFIED", "ONE_HOUR", "SIX_HOURS", "TWELVE_HOURS", "TWENTY_FOUR_HOURS", ""}),
										Description: `Optional. Available snapshot periods for scheduling.

- ONE_HOUR:	Snapshot every 1 hour.
- SIX_HOURS:	Snapshot every 6 hours.
- TWELVE_HOURS:	Snapshot every 12 hours.
- TWENTY_FOUR_HOURS:	Snapshot every 24 hours. Possible values: ["SNAPSHOT_PERIOD_UNSPECIFIED", "ONE_HOUR", "SIX_HOURS", "TWELVE_HOURS", "TWENTY_FOUR_HOURS"]`,
									},
									"rdb_snapshot_start_time": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `The time that the first snapshot was/will be attempted, and to which
future snapshots will be aligned.
If not provided, the current time will be used.`,
									},
								},
							},
						},
					},
				},
			},
			"psc_configs": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `Required. Each PscConfig configures the consumer network where two
network addresses will be designated to the cluster for client access.
Currently, only one PscConfig is supported.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"network": {
							Type:     schema.TypeString,
							Required: true,
							Description: `Required. The consumer network where the network address of
the discovery endpoint will be reserved, in the form of
projects/{network_project_id_or_number}/global/networks/{network_id}.`,
						},
					},
				},
			},
			"redis_configs": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Configure Redis Cluster behavior using a subset of native Redis configuration parameters.
Please check Memorystore documentation for the list of supported parameters:
https://cloud.google.com/memorystore/docs/cluster/supported-instance-configurations`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"region": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `The name of the region of the Redis cluster.`,
			},
			"replica_count": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: `Optional. The number of replica nodes per shard.`,
			},
			"transit_encryption_mode": {
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateEnum([]string{"TRANSIT_ENCRYPTION_MODE_UNSPECIFIED", "TRANSIT_ENCRYPTION_MODE_DISABLED", "TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION", ""}),
				Description: `Optional. The in-transit encryption for the Redis cluster.
If not provided, encryption is disabled for the cluster. Default value: "TRANSIT_ENCRYPTION_MODE_DISABLED" Possible values: ["TRANSIT_ENCRYPTION_MODE_UNSPECIFIED", "TRANSIT_ENCRYPTION_MODE_DISABLED", "TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION"]`,
				Default: "TRANSIT_ENCRYPTION_MODE_DISABLED",
			},
			"zone_distribution_config": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `Immutable. Zone distribution config for Memorystore Redis cluster.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"mode": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"MULTI_ZONE", "SINGLE_ZONE", ""}),
							Description: `Immutable. The mode for zone distribution for Memorystore Redis cluster.
If not provided, MULTI_ZONE will be used as default Possible values: ["MULTI_ZONE", "SINGLE_ZONE"]`,
						},
						"zone": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Immutable. The zone for single zone Memorystore Redis cluster.`,
						},
					},
				},
			},
			"available_maintenance_versions": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `This field is used to determine the available maintenance versions for the self service update.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"backup_collection": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The backup collection full resource name.
Example: projects/{project}/locations/{location}/backupCollections/{collection}`,
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The timestamp associated with the cluster creation request. A timestamp in
RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional
digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
			},
			"discovery_endpoints": {
				Type:     schema.TypeList,
				Computed: true,
				Description: `Output only. Endpoints created on each given network,
for Redis clients to connect to the cluster.
Currently only one endpoint is supported.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"address": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Output only. Network address of the exposed Redis endpoint used by clients to connect to the service.`,
						},
						"port": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `Output only. The port number of the exposed Redis endpoint.`,
						},
						"psc_config": {
							Type:     schema.TypeList,
							Optional: true,
							Description: `Output only. Customer configuration for where the endpoint
is created and accessed from.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"network": {
										Type:     schema.TypeString,
										Optional: true,
										Description: `The consumer network where the network address of the discovery
endpoint will be reserved, in the form of
projects/{network_project_id}/global/networks/{network_id}.`,
									},
								},
							},
						},
					},
				},
			},
			"effective_maintenance_version": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `This field represents the actual maintenance version of the cluster.`,
			},
			"maintenance_schedule": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Upcoming maintenance schedule.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
			},
			"managed_server_ca": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Cluster's Certificate Authority. This field will only be populated if Redis Cluster's transit_encryption_mode is TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
			},
			"precise_size_gb": {
				Type:        schema.TypeFloat,
				Computed:    true,
				Description: `Output only. Redis memory precise size in GB for the entire cluster.`,
			},
			"psc_connections": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. PSC connections for discovery of the cluster topology and accessing the cluster.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"address": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Output only. The IP allocated on the consumer network for the PSC forwarding rule.`,
						},
						"forwarding_rule": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Output only. The URI of the consumer side forwarding rule. Example: projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.`,
						},
						"network": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The consumer network where the IP address resides, in the form of projects/{projectId}/global/networks/{network_id}.`,
						},
						"project_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Output only. The consumer projectId where the forwarding rule is created from.`,
						},
						"psc_connection_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Output only. The PSC connection id of the forwarding rule connected to the service attachment.`,
						},
					},
				},
			},
			"psc_service_attachments": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Service attachment details to configure Psc connections.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
			},
			"size_gb": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `Output only. Redis memory size in GB for the entire cluster.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The current state of this cluster. Can be CREATING, READY, UPDATING, DELETING and SUSPENDED`,
			},
			"state_info": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. Additional information about the current state of the cluster.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"update_info": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `A nested object resource.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"target_replica_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Target number of replica nodes per shard.`,
									},
									"target_shard_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Target number of shards for redis cluster.`,
									},
								},
							},
						},
					},
				},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `System assigned, unique identifier for the cluster.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}
