// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This code is generated by Magic Modules using the following:
//
//     Configuration: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/products/compute/Subnetwork.yaml
//     Template:      https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/templates/tgc_next/services/resource.go.tmpl
//
//     DO NOT EDIT this file directly. Any changes made to this file will be
//     overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------

package compute

import (
	"context"
	"log"
	"net"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v6/pkg/tpgresource"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v6/pkg/verify"
	"github.com/apparentlymart/go-cidr/cidr"
)

const ComputeSubnetworkAssetType string = "compute.googleapis.com/Subnetwork"

const ComputeSubnetworkSchemaName string = "google_compute_subnetwork"

// Whether the IP CIDR change shrinks the block.
func IsShrinkageIpCidr(_ context.Context, old, new, _ interface{}) bool {
	_, oldCidr, oldErr := net.ParseCIDR(old.(string))
	_, newCidr, newErr := net.ParseCIDR(new.(string))

	if oldErr != nil || newErr != nil {
		// This should never happen. The ValidateFunc on the field ensures it.
		return false
	}

	oldStart, oldEnd := cidr.AddressRange(oldCidr)

	if newCidr.Contains(oldStart) && newCidr.Contains(oldEnd) {
		// This is a CIDR range expansion, no need to ForceNew, we have an update method for it.
		return false
	}

	return true
}

func sendSecondaryIpRangeIfEmptyDiff(_ context.Context, diff *schema.ResourceDiff, meta interface{}) error {
	// on create, return immediately as we don't need to determine if the value is empty or not
	if diff.Id() == "" {
		return nil
	}

	sendZero := diff.Get("send_secondary_ip_range_if_empty").(bool)
	if !sendZero {
		return nil
	}

	configSecondaryIpRange := diff.GetRawConfig().GetAttr("secondary_ip_range")
	if !configSecondaryIpRange.IsKnown() {
		return nil
	}
	configValueIsEmpty := configSecondaryIpRange.IsNull() || configSecondaryIpRange.LengthInt() == 0

	stateSecondaryIpRange := diff.GetRawState().GetAttr("secondary_ip_range")
	if !stateSecondaryIpRange.IsKnown() {
		return nil
	}
	stateValueIsEmpty := stateSecondaryIpRange.IsNull() || stateSecondaryIpRange.LengthInt() == 0

	if configValueIsEmpty && !stateValueIsEmpty {
		log.Printf("[DEBUG] setting secondary_ip_range to newly empty")
		diff.SetNew("secondary_ip_range", make([]interface{}, 0))
	}

	return nil
}

func ResourceComputeSubnetwork() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"name": {
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: verify.ValidateGCEName,
				Description: `The name of the resource, provided by the client when initially
creating the resource. The name must be 1-63 characters long, and
comply with RFC1035. Specifically, the name must be 1-63 characters
long and match the regular expression '[a-z]([-a-z0-9]*[a-z0-9])?' which
means the first character must be a lowercase letter, and all
following characters must be a dash, lowercase letter, or digit,
except the last character, which cannot be a dash.`,
			},
			"network": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description: `The network this subnet belongs to.
Only networks that are in the distributed mode can have subnetworks.`,
			},
			"allow_subnet_cidr_routes_overlap": {
				Type:     schema.TypeBool,
				Computed: true,
				Optional: true,
				Description: `Typically packets destined to IPs within the subnetwork range that do not match
existing resources are dropped and prevented from leaving the VPC.
Setting this field to true will allow these packets to match dynamic routes injected
via BGP even if their destinations match existing subnet ranges.`,
			},
			"description": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `An optional description of this resource. Provide this property when
you create the resource. This field can be set only at resource
creation time.`,
			},
			"external_ipv6_prefix": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `The range of external IPv6 addresses that are owned by this subnetwork.`,
			},
			"ip_cidr_range": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ValidateFunc: verify.ValidateIpCidrRange,
				Description: `The range of internal addresses that are owned by this subnetwork.
Provide this property when you create the subnetwork. For example,
10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
non-overlapping within a network. Only IPv4 is supported.
Field is optional when 'reserved_internal_range' is defined, otherwise required.`,
			},
			"ip_collection": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `Resource reference of a PublicDelegatedPrefix. The PDP must be a sub-PDP
in EXTERNAL_IPV6_SUBNETWORK_CREATION mode.
Use one of the following formats to specify a sub-PDP when creating an
IPv6 NetLB forwarding rule using BYOIP:
Full resource URL, as in:
  * 'https://www.googleapis.com/compute/v1/projects/{{projectId}}/regions/{{region}}/publicDelegatedPrefixes/{{sub-pdp-name}}'
Partial URL, as in:
  * 'projects/{{projectId}}/regions/region/publicDelegatedPrefixes/{{sub-pdp-name}}'
  * 'regions/{{region}}/publicDelegatedPrefixes/{{sub-pdp-name}}'`,
			},
			"ipv6_access_type": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"EXTERNAL", "INTERNAL", ""}),
				Description: `The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
cannot enable direct path. Possible values: ["EXTERNAL", "INTERNAL"]`,
			},
			"log_config": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `This field denotes the VPC flow logging options for this subnetwork. If
logging is enabled, logs are exported to Cloud Logging. Flow logging
isn't supported if the subnet 'purpose' field is set to subnetwork is
'REGIONAL_MANAGED_PROXY' or 'GLOBAL_MANAGED_PROXY'.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"aggregation_interval": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"INTERVAL_5_SEC", "INTERVAL_30_SEC", "INTERVAL_1_MIN", "INTERVAL_5_MIN", "INTERVAL_10_MIN", "INTERVAL_15_MIN", ""}),
							Description: `Can only be specified if VPC flow logging for this subnetwork is enabled.
Toggles the aggregation interval for collecting flow logs. Increasing the
interval time will reduce the amount of generated flow logs for long
lasting connections. Default is an interval of 5 seconds per connection. Default value: "INTERVAL_5_SEC" Possible values: ["INTERVAL_5_SEC", "INTERVAL_30_SEC", "INTERVAL_1_MIN", "INTERVAL_5_MIN", "INTERVAL_10_MIN", "INTERVAL_15_MIN"]`,
							Default:      "INTERVAL_5_SEC",
							AtLeastOneOf: []string{"log_config.0.aggregation_interval", "log_config.0.flow_sampling", "log_config.0.metadata", "log_config.0.filter_expr"},
						},
						"filter_expr": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
The default value is 'true', which evaluates to include everything.`,
							Default:      "true",
							AtLeastOneOf: []string{"log_config.0.aggregation_interval", "log_config.0.flow_sampling", "log_config.0.metadata", "log_config.0.filter_expr"},
						},
						"flow_sampling": {
							Type:     schema.TypeFloat,
							Optional: true,
							Description: `Can only be specified if VPC flow logging for this subnetwork is enabled.
The value of the field must be in [0, 1]. Set the sampling rate of VPC
flow logs within the subnetwork where 1.0 means all collected logs are
reported and 0.0 means no logs are reported. Default is 0.5 which means
half of all collected logs are reported.`,
							Default:      0.5,
							AtLeastOneOf: []string{"log_config.0.aggregation_interval", "log_config.0.flow_sampling", "log_config.0.metadata", "log_config.0.filter_expr"},
						},
						"metadata": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"EXCLUDE_ALL_METADATA", "INCLUDE_ALL_METADATA", "CUSTOM_METADATA", ""}),
							Description: `Can only be specified if VPC flow logging for this subnetwork is enabled.
Configures whether metadata fields should be added to the reported VPC
flow logs. Default value: "INCLUDE_ALL_METADATA" Possible values: ["EXCLUDE_ALL_METADATA", "INCLUDE_ALL_METADATA", "CUSTOM_METADATA"]`,
							Default:      "INCLUDE_ALL_METADATA",
							AtLeastOneOf: []string{"log_config.0.aggregation_interval", "log_config.0.flow_sampling", "log_config.0.metadata", "log_config.0.filter_expr"},
						},
						"metadata_fields": {
							Type:     schema.TypeSet,
							Optional: true,
							Description: `List of metadata fields that should be added to reported logs.
Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
							Set: schema.HashString,
						},
					},
				},
			},
			"params": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Additional params passed with the request, but not persisted as part of resource payload`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"resource_manager_tags": {
							Type:     schema.TypeMap,
							Optional: true,
							ForceNew: true,
							Description: `Resource manager tags to be bound to the subnetwork. Tag keys and values have the
same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id},
and values are in the format tagValues/456. The field is ignored when empty.
The field is immutable and causes resource replacement when mutated. This field is only
set at create time and modifying this field after creation will trigger recreation.
To apply tags to an existing resource, see the google_tags_tag_binding resource.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"private_ip_google_access": {
				Type:     schema.TypeBool,
				Computed: true,
				Optional: true,
				Description: `When enabled, VMs in this subnetwork without external IP addresses can
access Google APIs and services by using Private Google Access.`,
			},
			"private_ipv6_google_access": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				Description: `The private IPv6 google access type for the VMs in this subnet.`,
			},
			"purpose": {
				Type:     schema.TypeString,
				Computed: true,
				Optional: true,
				Description: `The purpose of the resource. This field can be either 'PRIVATE', 'REGIONAL_MANAGED_PROXY', 'GLOBAL_MANAGED_PROXY', 'PRIVATE_SERVICE_CONNECT', 'PEER_MIGRATION' or 'PRIVATE_NAT'([Beta](https://terraform.io/docs/providers/google/guides/provider_versions.html)).
A subnet with purpose set to 'REGIONAL_MANAGED_PROXY' is a user-created subnetwork that is reserved for regional Envoy-based load balancers.
A subnetwork in a given region with purpose set to 'GLOBAL_MANAGED_PROXY' is a proxy-only subnet and is shared between all the cross-regional Envoy-based load balancers.
A subnetwork with purpose set to 'PRIVATE_SERVICE_CONNECT' reserves the subnet for hosting a Private Service Connect published service.
A subnetwork with purpose set to 'PEER_MIGRATION' is a user created subnetwork that is reserved for migrating resources from one peered network to another.
A subnetwork with purpose set to 'PRIVATE_NAT' is used as source range for Private NAT gateways.
Note that 'REGIONAL_MANAGED_PROXY' is the preferred setting for all regional Envoy load balancers.
If unspecified, the purpose defaults to 'PRIVATE'.`,
			},
			"region": {
				Type:             schema.TypeString,
				Computed:         true,
				Optional:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `The GCP region for this subnetwork.`,
			},
			"reserved_internal_range": {
				Type:             schema.TypeString,
				Optional:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description: `The ID of the reserved internal range. Must be prefixed with 'networkconnectivity.googleapis.com'
E.g. 'networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}'`,
			},
			"role": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"ACTIVE", "BACKUP", ""}),
				Description: `The role of subnetwork.
Currently, this field is only used when 'purpose' is 'REGIONAL_MANAGED_PROXY'.
The value can be set to 'ACTIVE' or 'BACKUP'.
An 'ACTIVE' subnetwork is one that is currently being used for Envoy-based load balancers in a region.
A 'BACKUP' subnetwork is one that is ready to be promoted to 'ACTIVE' or is currently draining. Possible values: ["ACTIVE", "BACKUP"]`,
			},
			"secondary_ip_range": {
				Type:     schema.TypeList,
				Computed: true,
				Optional: true,
				Description: `An array of configurations for secondary IP ranges for VM instances
contained in this subnetwork. The primary IP of such VM must belong
to the primary ipCidrRange of the subnetwork. The alias IPs may belong
to either primary or secondary ranges.

**Note**: This field uses [attr-as-block mode](https://www.terraform.io/docs/configuration/attr-as-blocks.html) to avoid
breaking users during the 0.12 upgrade. To explicitly send a list of zero objects,
set 'send_secondary_ip_range_if_empty = true'`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"range_name": {
							Type:         schema.TypeString,
							Required:     true,
							ValidateFunc: verify.ValidateGCEName,
							Description: `The name associated with this subnetwork secondary range, used
when adding an alias IP range to a VM instance. The name must
be 1-63 characters long, and comply with RFC1035. The name
must be unique within the subnetwork.`,
						},
						"ip_cidr_range": {
							Type:         schema.TypeString,
							Computed:     true,
							Optional:     true,
							ValidateFunc: verify.ValidateIpCidrRange,
							Description: `The range of IP addresses belonging to this subnetwork secondary
range. Provide this property when you create the subnetwork.
Ranges must be unique and non-overlapping with all primary and
secondary IP ranges within a network. Only IPv4 is supported.
Field is optional when 'reserved_internal_range' is defined, otherwise required.`,
						},
						"reserved_internal_range": {
							Type:             schema.TypeString,
							Optional:         true,
							DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
							Description: `The ID of the reserved internal range. Must be prefixed with 'networkconnectivity.googleapis.com'
E.g. 'networkconnectivity.googleapis.com/projects/{project}/locations/global/internalRanges/{rangeId}'`,
						},
					},
				},
			},
			"stack_type": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"IPV4_ONLY", "IPV4_IPV6", "IPV6_ONLY", ""}),
				Description: `The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
If not specified IPV4_ONLY will be used. Possible values: ["IPV4_ONLY", "IPV4_IPV6", "IPV6_ONLY"]`,
			},
			"creation_timestamp": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Creation timestamp in RFC3339 text format.`,
			},
			"gateway_address": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The gateway address for default routes to reach destination addresses
outside this subnetwork.`,
			},
			"internal_ipv6_prefix": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The internal IPv6 address range that is assigned to this subnetwork.`,
			},
			"ipv6_cidr_range": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The range of internal IPv6 addresses that are owned by this subnetwork.`,
			},
			"ipv6_gce_endpoint": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Possible endpoints of this subnetwork. It can be one of the following:
  * VM_ONLY: The subnetwork can be used for creating instances and IPv6 addresses with VM endpoint type. Such a subnetwork
  gets external IPv6 ranges from a public delegated prefix and cannot be used to create NetLb.
  * VM_AND_FR: The subnetwork can be used for creating both VM instances and Forwarding Rules. It can also be used to reserve
  IPv6 addresses with both VM and FR endpoint types. Such a subnetwork gets its IPv6 range from Google IP Pool directly.`,
			},
			"state": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `'The state of the subnetwork, which can be one of the following values:
 READY: Subnetwork is created and ready to use DRAINING: only applicable to subnetworks that have the purpose
 set to INTERNAL_HTTPS_LOAD_BALANCER and indicates that connections to the load balancer are being drained.
 A subnetwork that is draining cannot be used or modified until it reaches a status of READY'`,
			},
			"subnetwork_id": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The unique identifier number for the resource. This identifier is defined by the server.`,
			},
			"send_secondary_ip_range_if_empty": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `Controls the removal behavior of secondary_ip_range.
When false, removing secondary_ip_range from config will not produce a diff as
the provider will default to the API's value.
When true, the provider will treat removing secondary_ip_range as sending an
empty list of secondary IP ranges to the API.
Defaults to false.`,
			},
			"fingerprint": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Fingerprint of this resource. This field is used internally during updates of this resource.",
				Deprecated:  "This field is not useful for users, and has been removed as an output.",
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"self_link": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
		UseJSONNumber: true,
	}
}
